<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狼狼的蓝胖子]]></title>
  <subtitle><![CDATA[我只是想写点字]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luopq.com/"/>
  <updated>2016-02-03T16:39:19.425Z</updated>
  <id>http://luopq.com/</id>
  
  <author>
    <name><![CDATA[LuoPQ]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[js插件开发的一些感想和心得]]></title>
    <link href="http://luopq.com/2016/02/04/write-js-plugin/"/>
    <id>http://luopq.com/2016/02/04/write-js-plugin/</id>
    <published>2016-02-03T16:36:40.000Z</published>
    <updated>2016-02-03T16:39:19.425Z</updated>
    <content type="html"><![CDATA[<h3 id="起因">起因</h3><p>如果大家平时做过一些前端开发方面的工作，一定会有这样的体会：页面需要某种效果或者插件的时候，我们一般会有两种选择：<br>1、上网查找相关的JS插件，学习其用法<br>2、自己造轮子，开发插件。</p>
<h4 id="寻找存在的插件">寻找存在的插件</h4><p>第一种做法，上网查找JS插件<br>这种方式如果是有刚好符合项目需求的插件，那是非常幸运的事了。但是我相信大部分情况下，我们找到的插件会有下面的几个问题：<br>（1）UI定制：很多插件提供的UI和我们的项目设计风格完全不搭，可能写好的html和css不符合插件使用的方式，结果我们还要去修改html和css来适应插件的用法。<br>（2）学习成本：如果是比较复杂的插件，存在着一个学习成本的问题，要去学习这个插件怎么使用。<br>（3）插件不符合需求：我们找到的插件并不完全保证符合我们项目的需求，这个时候你可能要去修改它的代码来支持项目需求，这也是可能存在的问题<br>（4）插件功能太大而全：假设你的项目需要一个简单的轮播插件，结果找到一个很牛逼的轮播插件，各种酷炫的效果，而且刚好也能使用，但是这个插件的体积和一个js库的体积差不多，而如果自己写效果的话，其实只要几十行代码就可以搞定了，这时候引入这个插件是否太过多余了。<br>这是使用js插件可能存在的一些问题，当然具体情况具体分析，我也并非不使用已经写好的js插件，毕竟有些插件是经过了时间考验的，使用起来更有益于项目的进行。如果是下面几种情况，我会考虑使用已经存在的js插件：<br>（1）复杂的功能：比如文件上传，批量上传，进度显示等等，比如HTML编辑器<br>（2）项目工期紧急，对性能要求不高的场景<br>（3）js插件刚好符合项目的需求</p>
<h4 id="自己造轮子">自己造轮子</h4><p>第二种做法，自己造轮子开发插件<br>自己写插件主要有下面几个问题：<br>（1）开发插件需要时间，可能拖延项目工期，如果工期紧急不建议选用这种方式<br>（2）自己造的轮子未必有现有轮子的好用，要考虑到队友是否适用<br>（3）需要比较高的开发水平<br>如果平时项目不紧急的话，我会考虑自己造轮子，主要有几个好处：<br>（1）完全符合项目需求，这一条是显而易见的，因为完全针对项目来开发的插件<br>（2）知根知底，容易修改，插件完全是自己开发的，项目有什么需求变化完全可以灵活应对<br>（3）轻量级，因为我们不像其他开源插件要应对那么多种需求，所以我们自己的轮子也只需要符合自己的车，不需要很多变化，相对来说，变化少功能少，代码也会少。<br>（4）对个人能力是一个很大的锻炼，不要重复造轮子这是在程序员中广为流传的一句话，这也成为很多人偷懒的一个借口，但是我们不应该以此为借口来阻碍自己的前进的脚步。造过轮子的同学应该深有体会，造过一个轮子，远比你使用别人写的100个插件的收获还要多，我们的轮子可以不在项目中使用，但这是一种效率极高的学习方式，强烈推荐。</p>
<h3 id="如何开发一个轻量级的适用性强的插件">如何开发一个轻量级的适用性强的插件</h3><p>怎么开发一个适应性强的且轻量的插件呢？所谓适用性强，简单地说就是有几点：<br>1、对UI限制越少越好，最好没有<br>2、不提供太多功能，只提供简单的api，让使用者易于扩展</p>
<p>我们举个例子，假设我们要开发一个jQuery分页插件，关于jQuery插件开发教程，请参考<a href="http://www.cnblogs.com/wayou/p/jquery_plugin_tutorial.html" target="_blank">jQuery插件开发</a>。</p>
<h4 id="确定需求">确定需求</h4><p>确定需求是开发插件的第一步。要开发一个轻量级的分页插件，我们还是用从插件最基本的需求开始说起，分页插件最基本的需求是什么呢，无非就是页码显示，页码之间的切换，所以，我们的插件要围绕着这基本需求开始，而暂时不要考虑其他可能存在的需求。</p>
<h4 id="确定插件html和css">确定插件html和css</h4><p>确定好插件的需求后，第二步就是插件的UI，也就是html和css。<br>假设基本的ui如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/jquery-pager-demo.png" alt="基本的分页UI"><br>看到上面的基本ui，不知道大家会想到什么样的html结构。对于我们开发人员来说，html和css要越简单越好，所以最基本的html结构无非就是a标签和span标签的混合，有的同学可能会想到使用ul，li标签，但这其实增加的复杂度，得不偿失。我们编写html代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"pager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"flip noPage"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"curPage"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">page</span>=<span class="value">"1"</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">page</span>=<span class="value">"2"</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span>&gt;</span>3<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">page</span>=<span class="value">"3"</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span>&gt;</span>4<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span>&gt;</span>...<span class="tag">&lt;/<span class="title">span</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">page</span>=<span class="value">"8"</span>&gt;</span>9<span class="tag">&lt;/<span class="title">a</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">page</span>=<span class="value">"1"</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">class</span>=<span class="value">"flip"</span>&gt;</span>下一页<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这是最基本html代码结构，包含了分页插件的容器div.pager，当前页span.curPage，其他页码a标签，上一页，下一页等按钮。<br>接着是css代码，主要当前页标签，其他页面标签，上一页下一页，鼠标悬停在按钮上等几种样式，编写如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.pager</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">font</span>:<span class="value"> <span class="number">12</span> px/<span class="number">21px</span> <span class="string">"宋体"</span></span></span>; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.pager</span> <span class="tag">a</span>, <span class="class">.pager</span> <span class="class">.flip</span>, <span class="class">.pager</span> <span class="class">.curPage</span> <span class="rules">&#123; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#e3e3e3</span></span></span>; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">22px</span></span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">22px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line">    <span class="class">.pager</span> <span class="tag">a</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="hexcolor">#fff</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#010101</span></span></span>; <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">26px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.pager</span> <span class="rule"><span class="attribute">a</span>:<span class="value">hover &#123; background: none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="hexcolor">#f1f1f1</span></span></span>; &#125;</span><br><span class="line">    <span class="class">.pager</span> <span class="class">.noPage</span> <span class="rules">&#123; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#a4a4a4</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.pager</span> <span class="class">.curPage</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> none repeat scroll <span class="number">0</span> <span class="number">0</span> <span class="hexcolor">#49abde</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#ffffff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">26px</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.pager</span> <span class="class">.flip</span> <span class="rules">&#123; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">56px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="编写js代码">编写js代码</h4><p>写好基本的html和css，接下来最关键的就是js代码了。首先我们搭建好jQuery插件开发的基本形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params">$, window, document, undefined</span>) </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        pageIndex: <span class="number">0</span>,</span><br><span class="line">        pageSize: <span class="number">6</span>,</span><br><span class="line">        itemCount: <span class="number">50</span>,</span><br><span class="line">        maxButtonCount: <span class="number">7</span>,</span><br><span class="line">        prevText: <span class="string">"上一页"</span>,</span><br><span class="line">        nextText: <span class="string">"下一页"</span>,</span><br><span class="line">        buildPageUrl: <span class="literal">null</span>,</span><br><span class="line">        onPageChanged: <span class="literal">null</span></span><br><span class="line">    &#125;;   </span><br><span class="line"></span><br><span class="line">    $.fn.pager = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        options = $.extend(defaults, options || &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里主要提供了一些可选参数的默认值，比如页码默认为0，每页数量6条等等。<br>接着我们来考虑一下分页插件的思路：<br>1、设置当前页码为0，表示第一页<br>2、生成分页插件的html代码<br>3、修改页码，再生成html代码<br>基于这个思路，我们编写代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params">$, window, document, undefined</span>) </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> defaults = &#123;</span><br><span class="line">        pageIndex: <span class="number">0</span>,</span><br><span class="line">        pageSize: <span class="number">6</span>,</span><br><span class="line">        itemCount: <span class="number">50</span>,</span><br><span class="line">        maxButtonCount: <span class="number">7</span>,</span><br><span class="line">        prevText: <span class="string">"上一页"</span>,</span><br><span class="line">        nextText: <span class="string">"下一页"</span>,</span><br><span class="line">        buildPageUrl: <span class="literal">null</span>,</span><br><span class="line">        onPageChanged: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Pager</span>(<span class="params">$ele, options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$ele = $ele;</span><br><span class="line">        <span class="keyword">this</span>.options = options = $.extend(defaults, options || &#123;&#125;);</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    Pager.prototype = &#123;</span><br><span class="line">        constructor: Pager,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.renderHtml();</span><br><span class="line">            <span class="keyword">this</span>.bindEvent();</span><br><span class="line">        &#125;,</span><br><span class="line">        renderHtml: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> options = <span class="keyword">this</span>.options;</span><br><span class="line"></span><br><span class="line">            options.pageCount = <span class="built_in">Math</span>.ceil(options.itemCount / options.pageSize);</span><br><span class="line">            <span class="keyword">var</span> html = [];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成上一页的按钮</span></span><br><span class="line">            <span class="keyword">if</span> (options.pageIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                html.push(<span class="string">'&lt;a page="'</span> + (options.pageIndex - <span class="number">1</span>) + <span class="string">'" href="'</span> + <span class="keyword">this</span>.buildPageUrl(options.pageIndex + <span class="number">1</span>) + <span class="string">'" class="flip"&gt;'</span> + options.prevText + <span class="string">'&lt;/a&gt;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html.push(<span class="string">'&lt;span class="flip noPage"&gt;'</span> + options.prevText + <span class="string">'&lt;/span&gt;'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里是关键</span></span><br><span class="line">            <span class="comment">//临时的起始页码中间页码，当页码数量大于显示的最大按钮数时使用</span></span><br><span class="line">            <span class="keyword">var</span> tempStartIndex = options.pageIndex - <span class="built_in">Math</span>.floor(options.maxButtonCount / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算终止页码，通过max计算一排按钮中的第一个按钮的页码，然后计算出页数量</span></span><br><span class="line">            <span class="keyword">var</span> endIndex = <span class="built_in">Math</span>.min(options.pageCount, <span class="built_in">Math</span>.max(<span class="number">0</span>, tempStartIndex) + options.maxButtonCount) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> startIndex = <span class="built_in">Math</span>.max(<span class="number">0</span>, endIndex - options.maxButtonCount + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一页</span></span><br><span class="line">            <span class="keyword">if</span> (startIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                html.push(<span class="string">"&lt;a href='"</span> + <span class="keyword">this</span>.buildPageUrl(<span class="number">0</span>) + <span class="string">"' page='"</span> + <span class="number">0</span> + <span class="string">"'&gt;1&lt;/a&gt; "</span>);</span><br><span class="line">                html.push(<span class="string">"&lt;span&gt;...&lt;/span&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成页码按钮</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt;= endIndex; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (options.pageIndex == i) &#123;</span><br><span class="line">                    html.push(<span class="string">'&lt;span class="curPage"&gt;'</span> + (i + <span class="number">1</span>) + <span class="string">'&lt;/span&gt;'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    html.push(<span class="string">'&lt;a page="'</span> + i + <span class="string">'" href="'</span> + <span class="keyword">this</span>.buildPageUrl(options.pageIndex + <span class="number">1</span>) + <span class="string">'"&gt;'</span> + (i + <span class="number">1</span>) + <span class="string">'&lt;/a&gt;'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一页</span></span><br><span class="line">            <span class="keyword">if</span> (endIndex &lt; options.pageCount - <span class="number">1</span>) &#123;</span><br><span class="line">                html.push(<span class="string">"&lt;span&gt;...&lt;/span&gt; "</span>);</span><br><span class="line">                html.push(<span class="string">"&lt;a href='"</span> + <span class="keyword">this</span>.buildPageUrl(options.pageCount - <span class="number">1</span>) + <span class="string">"' page='"</span> + (options.pageCount - <span class="number">1</span>) + <span class="string">"'&gt;"</span> + options.pageCount + <span class="string">"&lt;/a&gt; "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成下一页的按钮</span></span><br><span class="line">            <span class="keyword">if</span> (options.pageIndex &lt; options.pageCount - <span class="number">1</span>) &#123;</span><br><span class="line">                html.push(<span class="string">'&lt;a page="'</span> + (options.pageIndex + <span class="number">1</span>) + <span class="string">'" href="'</span> + <span class="keyword">this</span>.buildPageUrl(options.pageIndex + <span class="number">1</span>) + <span class="string">'" class="flip"&gt;'</span> + options.nextText + <span class="string">'&lt;/a&gt;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                html.push(<span class="string">'&lt;span class="flip noPage"&gt;'</span> + options.nextText + <span class="string">'&lt;/span&gt;'</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.$ele.html(html.join(<span class="string">""</span>));</span><br><span class="line">        &#125;,</span><br><span class="line">        bindEvent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">            that.$ele.on(<span class="string">"click"</span>, <span class="string">"a"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                that.options.pageIndex = <span class="built_in">parseInt</span>($(<span class="keyword">this</span>).attr(<span class="string">"page"</span>), <span class="number">10</span>);</span><br><span class="line">                that.renderHtml();</span><br><span class="line">                that.options.onPageChanged &amp;&amp; that.options.onPageChange(that.options.pageIndex);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        buildPageUrl: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ($.isFunction(<span class="keyword">this</span>.options.buildPageUrl)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.options.buildPageUrl(pageIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"javascript:;"</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    $.fn.pager = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">        options = $.extend(defaults, options || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pager($(<span class="keyword">this</span>), options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)(jQuery, <span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></p>
<p>这段代码中有两个关键点要记住：<br>（1）html代码的生成，由于页码可能太多，需要隐藏部分页码，所以我们要生成一个省略号表示被隐藏的页码，通过maxButtonCount来表示最多的页码按钮<br>（2）事件绑定，每次页码改变都会重新生成html，我们采用事件代理的方式，提高了性能，也不用重复绑定事件<br>这样一个最基本的分页插件已经可以了。</p>
<p>但是这样足够了吗？<br>假设我们需要支持输入页码直接跳转的功能，那该如何呢，是否需要修改原有的html结构和css？前面我们说到，开发一个插件要围绕最基本的需求开始，那对于这些潜在的可能存在的需求又该如何处理呢。<br>我的解决方案是这样的，提供简单的api，不提供UI，完全由用户自定义。<br>我们在上面的代码增加三个api：getPageIndex，setPageIndex和setItemCount，分别表示获取当前索引，设置当前索引，设置项目总数量。代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getPageIndex: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.options.pageIndex;</span><br><span class="line">&#125;,</span><br><span class="line">setPageIndex: <span class="function"><span class="keyword">function</span> <span class="params">(pageIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options.pageIndex = pageIndex;</span><br><span class="line">    <span class="keyword">this</span>.renderHtml();</span><br><span class="line">&#125;,</span><br><span class="line">setItemCount: <span class="function"><span class="keyword">function</span> <span class="params">(itemCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.options.pageIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.options.itemCount = itemCount;</span><br><span class="line">    <span class="keyword">this</span>.renderHtml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整版代码请查看<a href="https://github.com/LuoPQ/jquery.pager.js/blob/master/src/jquery.pager.js" target="_blank" rel="external">jquery.page.js</a><br>提供了这三个api，假设用户需要跳转页码的功能，可以直接使用setPageIndex方法来跳转，UI完全由用户自定义，插件本身只专注基本功能，不干涉其它。<br>大家可以查看<a href="http://luopq.com/demo/pager/examples/index.html">DEMO</a></p>
<p>整个插件的代码已经放在我的github上，有兴趣的同学可以点击查看<a href="https://github.com/LuoPQ/jquery.pager.js" target="_blank" rel="external">github</a></p>
<h3 id="总结">总结</h3><p>最后，我整理一下我开发一些js插件的思路：<br>1、专注最基本的需求本身，暂时不考虑可能潜在的需求<br>2、尽量不提供或少提供UI，减少对使用者的限制<br>3、考虑可能潜在的需求，提供api，潜在的需求完全由用户自定义</p>
<p>这是我在编写js插件时，考虑如何轻量化并且适用性强的一些想法，欢迎大家交流！</p>
]]></content>
    <summary type="html">
    <![CDATA[如果大家平时做过一些前端开发方面的工作，一定会有这样的体会：页面需要某种效果或者插件的时候，我们一般会有两种选择： 1、上网查找相关的JS插件，学习其用法;2、自己造轮子，开发插件。本文主要谈谈一些编写JS插件的感想和心得]]>
    
    </summary>
    
      <category term="javascript" scheme="http://luopq.com/tags/javascript/"/>
    
      <category term="插件编写" scheme="http://luopq.com/tags/%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6：下一版本的JavaScript的新特性]]></title>
    <link href="http://luopq.com/2016/01/20/es6-next-javascript/"/>
    <id>http://luopq.com/2016/01/20/es6-next-javascript/</id>
    <published>2016-01-20T09:36:02.000Z</published>
    <updated>2016-01-23T13:25:10.211Z</updated>
    <content type="html"><![CDATA[<p>你可能已经听说过EMCAScript6（ES6）了，这是下一个版本的Javascript，它包含了一些很棒的新特性。这些特性拥有不同程度的复杂性，对于简单的脚本和复杂的应用程序都非常的有用。本文将盘点一些ES6的新特性，这些特性都可以用在你日常的编码中。<br>请注意，只有现代浏览器才能支持这些新的ES6特性，虽然浏览器的支持各不相同。如果你需要兼容那些不支持ES6新特性的旧浏览器，我也会谈谈关于这方面的解决方案。<br>在本文中，大部分示例代码都会带有“运行代码”的链接，读者可以点击链接运行示例。</p>
<h3 id="变量">变量</h3><h4 id="LET">LET</h4><p>通常我们使用var关键字来声明变量，现在我们同样可以使用let，它们之间的细微差别在于作用域。使用var声明变量时，该变量的作用域是其最近的函数，而使用let声明变量，它的作用域只在包含它的块。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    let x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(x);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以让代码更加干净整洁，可以减少无用的变量。<br>看看下面这个经典的数组循环：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(let i = 0,<span class="keyword">l</span> = <span class="keyword">list</span>.length;i &lt;  <span class="keyword">l</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="literal">log</span>(i);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>举个例子，经常会有人使用变量j在同一作用域中的另外一个循环中。但是使用let声明变量，你可以很安全地再声明一次，因为它只在自己块级作用域内定义和有效。</p>
<h4 id="CONST">CONST</h4><p>声明块级作用域内的变量的另一种方法是使用const。使用const，你可以声明一个只读的值，必须直接指定一个值，如果尝试改变它的值或者没有立即指定一个值，就会得到下面的错误：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_CO<span class="built_in">NSTANT</span> = <span class="number">1</span>;</span><br><span class="line">MY_CO<span class="built_in">NSTANT</span> = <span class="number">2</span>; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> SOME_CO<span class="built_in">NSTANT</span>;<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
<p>注意，你还是可以修改对象的属性或者数组的成员<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const MY_OBJECT = &#123;<span class="keyword">some</span>:<span class="number">1</span>&#125;;</span><br><span class="line">MY_OBJECT.<span class="keyword">some</span> = <span class="string">"some"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="箭头函数">箭头函数</h3><p>箭头函数对于Javascript来说是一个非常棒的补充，它可以让代码更加精简。我们首先来介绍箭头函数，在稍后的其他例子中就会使用到它的优点。下面的代码展示了一个箭头函数和我们熟悉的ES5风格的两种写法的函数：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = [&#123;title:<span class="string">'X'</span>,price:<span class="number">10</span>&#125;,&#123;title:<span class="string">'Y'</span>,price:<span class="number">15</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> titles = book.<span class="keyword">map</span>(<span class="literal">item</span> =&gt; <span class="literal">item</span>.title);</span><br><span class="line"></span><br><span class="line">//ES5 equivalent;</span><br><span class="line">var titles = book.<span class="keyword">map</span>(<span class="keyword">function</span>(<span class="literal">item</span>)&#123;</span><br><span class="line">    return item.title;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20books%20%3D%20%5B%7Btitle%3A%20'X'%2C%20price%3A%2010%7D%2C%20%7Btitle%3A%20'Y'%2C%20price%3A%2015%7D%5D%3B%0A%0Alet%20titles%20%3D%20books.map(%20item%20%3D%3E%20item.title%20)%3B%0A" target="_blank">运行代码</a></p>
<p>我们来看看箭头函数的语法，其中没有function关键字，剩下的就是0个或多个参数、(=&gt;)箭头和函数表达式。注意：return语句将隐式地被添加进来。</p>
<p>如果是0个或多个参数，必须添加括号：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有参数</span></span><br><span class="line">books.<span class="built_in">map</span>(()=&gt;<span class="number">1</span>);<span class="comment">//[1,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多个参数</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].<span class="built_in">map</span>((n,index) =&gt; n * index);[<span class="number">0</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p>
<p>如果需要更多的逻辑或者空白区域，可以将函数表达式放在({…})块中。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">result</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map(n =&gt;&#123;</span><br><span class="line">    n = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20result%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D.map(%20n%20%3D%3E%20%7B%0A%20%20%20%20n%20%3D%20n%20%25%203%3B%0A%20%20%20%20return%20n%3B%0A%7D)%3B" target="_blank">运行代码</a></p>
<p>箭头函数不仅仅意味着更少的字符，它的行为也不同于常规的函数。一个箭头函数从它的外界上下文中继承this和arguments关键字。这表示你可以摆脱以前那些难看的语句，比如var that = this，而且不需要绑定函数到正确的上下文中。下面有一个例子（注意：this.title等同于ES5版本的that.title）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">   title: <span class="string">'X'</span>,</span><br><span class="line">   sellers: [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">   printSellers() &#123;</span><br><span class="line">      <span class="keyword">this</span>.sellers.forEach(seller =&gt; <span class="built_in">console</span>.log(seller + <span class="string">' sells '</span> + <span class="keyword">this</span>.title));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">   title: <span class="string">'X'</span>,</span><br><span class="line">   sellers: [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">   printSellers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">this</span>.sellers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">seller</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(seller + <span class="string">' sells '</span> + that.title)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20book%20%3D%20%7B%0A%20%20%20%20title%3A%20'X'%2C%0A%20%20%20%20sellers%3A%20%5B'A'%2C%20'B'%5D%2C%0A%20%20%20%20printSellers()%20%7B%0A%20%20%20%20%20%20%20%20this.sellers.forEach(seller%20%3D%3E%20console.log(seller%20%2B%20'%20sells%20'%20%2B%20this.title))%3B%0A%20%20%20%20%7D%0A%7D" target="_blank">运行代码</a></p>
<h3 id="字符串">字符串</h3><h4 id="方法">方法</h4><p>String的prototype中添加了几个方便的方法，大部分是indexOf方法的变通：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">‘my <span class="keyword">string</span>’.<span class="keyword">startsWith</span>(<span class="string">'my'</span>);<span class="comment">//true</span></span><br><span class="line"><span class="string">'my string'</span>.<span class="keyword">endsWith</span>(<span class="string">'my'</span>);<span class="comment">//false</span></span><br><span class="line"><span class="string">'my string'</span>.includes(<span class="string">'str'</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>简单有效！另外，还添加了一个方便创建重复字符串的方法：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘<span class="keyword">my</span> ’.repeat(<span class="number">3</span>);<span class="regexp">//</span>‘<span class="keyword">my</span> <span class="keyword">my</span> <span class="keyword">my</span> ’</span><br></pre></td></tr></table></figure></p>
<h4 id="模板字符串">模板字符串</h4><p>模板字符串提供了一个简洁的方式去创建字符串和实现字符串插值。你可能已经熟悉了它的语法，模板字符串基于$符号和花括号${…}，要使用反撇号`将其包围。<br>下面是一个简单的演示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'John'</span>,</span><br><span class="line">   apples = <span class="number">5</span>,</span><br><span class="line">   pears = <span class="number">7</span>,</span><br><span class="line">   bananas = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`This is <span class="subst">$&#123;name&#125;</span>.`</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`He carries <span class="subst">$&#123;apples&#125;</span> apples, <span class="subst">$&#123;pears&#125;</span> pears, and <span class="subst">$&#123;bananas()&#125;</span> bananas.`</span>);</span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'He carries '</span> + apples + <span class="string">' apples, '</span> + pears + <span class="string">' pears, and '</span> + bananas() +<span class="string">' bananas.'</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20name%20%3D%20'John'%2C%0A%20%20%20%20apples%20%3D%205%2C%0A%20%20%20%20pears%20%3D%207%2C%0A%20%20%20%20bananas%20%3D%20function()%20%7B%20return%203%3B%20%7D%0A%0Aconsole.log(%60This%20is%20%24%7Bname%7D.%60)%3B%0A%0Aconsole.log(%60He%20carries%20%24%7Bapples%7D%20apples%2C%20%24%7Bpears%7D%20pears%2C%20and%20%24%7Bbananas()%7D%20bananas.%60)%3B%0A" target="_blank">运行代码</a></p>
<p>上面的示例中，和ES5相比较，模板字符串仅仅只是方便字符串的串联。模板字符串通常应用于多行字符串，请记住，空白是字符串的一部分。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let x = `<span class="number">1.</span>..</span><br><span class="line"><span class="number">2.</span>..</span><br><span class="line"><span class="number">3</span> lines <span class="keyword">long</span>!`; <span class="comment">// Yay</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalents:</span></span><br><span class="line">var x = <span class="string">"1...\n"</span> +</span><br><span class="line"><span class="string">"2...\n"</span> +</span><br><span class="line"><span class="string">"3 lines long!"</span>;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20x%20%3D%20%601...%0A2...%0A3%20lines%20long!%60%3B" target="_blank">运行代码</a></p>
<h3 id="数组">数组</h3><p>Array对象现在新增了一些静态方法以及prototype上的一些方法。<br>第一、Array.from方法从类数组或可迭代对象上创建Array的实例。类数组对象的例子包括：<br>1、函数中的arguments对象<br>2、document.getElementsByTagName放回的一个nodeList对象<br>3、新的Map和Set数据结构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> itemElements = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.items'</span>);</span><br><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.from(itemElements);</span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element.nodeType)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A workaround often used in ES5:</span></span><br><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.prototype.slice.call(itemElements);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20itemElements%20%3D%20document.querySelectorAll('div')%3B%0Alet%20items%20%3D%20Array.from(itemElements)%3B%0Aitems.forEach(function(element)%20%7B%0A%20%20%20%20console.log(element.nodeType)%0A%7D)%3B%0A" target="_blank">运行代码</a><br>上面的示例中，可以看出items数组拥有forEach方法，但是在itemElements集合中，这个方法是不可用的。</p>
<p>Array.from有一个有趣的特性是它的第二个可选参数mapFunction，这个参数允许在单次调用中创建一个新的映射数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> navElements = <span class="built_in">document</span>.querySelectorAll(<span class="string">'nav li'</span>);</span><br><span class="line"><span class="keyword">let</span> navTitles = <span class="built_in">Array</span>.from(navElements, el =&gt; el.textContent);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20navElements%20%3D%20document.querySelectorAll('nav%20li')%3B%0Alet%20navTitles%20%3D%20Array.from(navElements%2C%20el%20%3D%3E%20el.textContent)%3B%0Aconsole.log(navTitles.join(''))%3B" target="_blank">运行代码</a></p>
<p>第二、Array.of方法，这个方法的行为有点像Array的构造函数，它修复了传递单个数字参数时的特殊情况，所以Array.of相比于new Array()更好。不过大多数情况下，我们推荐使用数组字面量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x = <span class="keyword">new</span> Array(<span class="number">3</span>); <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line">let y = Array.of(<span class="number">8</span>); <span class="comment">// [8]</span></span><br><span class="line">let z = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// Array literal</span></span><br></pre></td></tr></table></figure></p>
<p>最后，Array的prototype中添加了几个方法，其中的find方法我觉得Javascript开发者将会非常喜欢。<br>1、find方法：获取回调函数return true的第一个元素。<br>2、findIndex方法：获取回调函数return true的第一个元素的索引<br>3、fill方法：根据给定的参数重写数组的元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>].find(n =&gt; n === <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>].findIndex(n =&gt; n === <span class="number">10</span>) <span class="comment">// 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>) <span class="comment">// [7, 7, 7]</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// [0, 7, 7, 7, 0]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Math">Math</h3><p>Math对象也添加了几个方法。<br>1、Math.sign 返回一个数字的符号，有1，-1或0三个值分别表示正值，负值或0<br>2、Math.trunc 返回一个数字去掉小数位数后的数<br>3、Math.cbrt 返回一个数字的立方根<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(<span class="number">5</span>); <span class="comment">// 1</span></span><br><span class="line">Math.sign(-<span class="number">9</span>); <span class="comment">// -1</span></span><br><span class="line">Math.trunc(<span class="number">5.9</span>); <span class="comment">// 5</span></span><br><span class="line">Math.trunc(<span class="number">5.123</span>); <span class="comment">// 5</span></span><br><span class="line">Math.cbrt(<span class="number">64</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>如果你想要学习更多的新的Math内容，点击<a href="http://www.2ality.com/2015/04/numbers-math-es6.html" target="_blank" rel="external">new number and math features in ES6</a>。</p>
<h3 id="扩展操作符">扩展操作符</h3><p>扩展操作符(…)是一个非常方便的语法，它用于在数组的特殊的地方扩展元素，比如函数调用中的参数。下面展示一些例子来说明它的用处。<br>首先，我们来看看如何通过另一个数组来扩展数组的元素：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];let some = [...values, <span class="number">8</span>]; <span class="comment">// [1, 2, 4, 8]</span></span><br><span class="line">let more = [...values, <span class="number">8</span>, ...values]; <span class="comment">// [1, 2, 4, 8, 1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line">let values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// Iterate, push, sweat, repeat...</span></span><br><span class="line"><span class="comment">// Iterate, push, sweat, repeat...</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20values%20%3D%20%5B1%2C%202%2C%204%5D%3B%0Alet%20some%20%3D%20%5B...values%2C%208%5D%3B%0Alet%20more%20%3D%20%5B...values%2C%208%2C%20...values%5D%3B%0Aconsole.log(some)%3B%0Aconsole.log(more)%3B" target="_blank">运行代码</a></p>
<p>当使用参数调用函数时，扩展操作符同样非常强大。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];doSomething(...values);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x, y, z</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// x = 1, y = 2, z = 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line">doSomething.apply(<span class="literal">null</span>, values);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20values%20%3D%20%5B1%2C%202%2C%204%5D%3B%0AdoSomething(...values)%3B%0Afunction%20doSomething(x%2C%20y%2C%20z)%20%7B%0A%20%20%20%20console.log(arguments)%3B%0A%7D%0A" target="_blank">运行代码</a></p>
<p>正如你所看到的，这避免了我们经常使用的fn.apply()这种委婉曲折的方式。扩展操作符语法非常灵活，因为它可以在参数列表的任何地方使用，即下面的调用方式也会产生一样的结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let values = [<span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">doSomething(<span class="number">1</span>, ...values);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=let%20values%20%3D%20%5B2%2C%204%5D%3B%0AdoSomething(1%2C%20...values)%3B%0Afunction%20doSomething(x%2C%20y%2C%20z)%20%7B%0A%20%20%20%20console.log(arguments)%3B%0A%7D" target="_blank">运行代码</a></p>
<p>我们已经将扩展操作符应用到Array和arguents中了。实际上，所有的可迭代的对象都可以应用扩展操作符，比如NodeList：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let form = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#my-form'</span>),</span><br><span class="line">   inputs = form.<span class="built_in">querySelectorAll</span>(<span class="string">'input'</span>),</span><br><span class="line">   selects = form.<span class="built_in">querySelectorAll</span>(<span class="string">'select'</span>);</span><br><span class="line">let allTheThings = [form, ...inputs, ...selects];</span><br></pre></td></tr></table></figure></p>
<p><a href="http://jsbin.com/vibaxerino/edit?html,js,console" target="_blank" rel="external">运行代码</a><br>现在allTheThings变成一个扁平的数组，其中包含form节点，input和select的子节点。</p>
<h3 id="解构">解构</h3><p>解构提供了一个便捷的方式来从对象或数组中提取数据。下面给了一个使用数组的典型例子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [x,y] = [<span class="number">1</span>,<span class="number">2</span>];<span class="comment">// x = 1, y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var x = arr[<span class="number">0</span>];</span><br><span class="line">var y = arr[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>使用这种语法，可以一次性指定多个变量。还有另外一个作用是可以很简单的交换两个变量值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x = <span class="number">1</span>,</span><br><span class="line">     y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];<span class="comment">// x = 2, y = 1</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=let%20x%20%3D%201%2C%0A%20%20%20%20y%20%3D%202%3B%0A%0A%5Bx%2C%20y%5D%20%3D%20%5By%2C%20x%5D%3B%0A" target="_blank" rel="external">运行代码</a></p>
<p>解构也能用于对象上，要保证key值匹配。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = [x: <span class="number">1</span>,y: <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;x, y&#125; = obj; <span class="comment">// x = 1, y = 2</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=let%20obj%20%3D%20%7Bx%3A%201%2C%20y%3A%202%7D%3B%0Alet%20%7Bx%2C%20y%7D%20%3D%20obj%3B" target="_blank" rel="external">运行代码</a></p>
<p>也可以通过这个机制来修改变量的名称<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;<span class="string">x:</span><span class="number">1</span> ,<span class="string">y:</span> <span class="number">2</span>&#125;</span><br><span class="line">let &#123;<span class="string">x:</span> a,<span class="string">y:</span> b&#125; = obj;<span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure></p>
<p>还有另外一个有趣的用法是模拟多个返回值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x, y] = doSomething(); <span class="comment">// x = 1,y = 2</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&amp;evaluate=true&amp;loose=true&amp;spec=false&amp;code=function%20doSomething(" target="_blank" rel="external">运行代码</a>%20%7B%0A%20%20%20%20return%20%5B1%2C%202%5D%0A%7D%0A%0Alet%20%5Bx%2C%20y%5D%20%3D%20doSomething()%3B)</p>
<p>解构同样也可以指定argument对象的默认值，通过字面量对象，可以模拟命名参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">doSomething</span><span class="params">(&#123; y = <span class="number">1</span>,z = <span class="number">0</span> &#125;)</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(y, z);</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&#123;y: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="参数">参数</h3><h4 id="默认值">默认值</h4><p>在ES6中，是可以给函数参数定义一个默认值的，语法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">doSomething</span><span class="params">(x, y = <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line">doSomething(<span class="number">5</span>); <span class="comment">//10</span></span><br><span class="line">doSomething(<span class="number">5</span>, undefined); <span class="comment">//10</span></span><br><span class="line">doSomething(<span class="number">5</span>, <span class="number">3</span>);<span class="comment">// 15</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=true&spec=false&code=function%20doSomething(x%2C%20y%20%3D%202)%20%7B%0A%20%20%20%20return%20x%20*%20y%3B%0A%7D%0A%0Aconsole.log(doSomething(5))%3B%0Aconsole.log(doSomething(5%2C%20undefined))%3B%0Aconsole.log(doSomething(5%2C%203))%3B" target="_blank">运行代码</a></p>
<p>这样看起来就简洁多了，如果是ES5之前的写法，我们肯定要补充一些参数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    y = y === <span class="literal">undefined</span> ? <span class="number">2</span> : y;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>undefined或者无参时将会触发参数的默认值。</p>
<h4 id="剩余不定参数">剩余不定参数</h4><p>我们已经看过了扩展操作符，不定参数与其非常相似。不定参数也使用…语法，它允许将函数末端的参数存储在一个数组里面。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(x,<span class="rest_arg">...remaining</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * remaining.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">// 15</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=function%20doSomething(x%2C%20...remaining)%20%7B%0A%20%20%20%20return%20x%20*%20remaining.length%3B%0A%7D%0A%0AdoSomething(5%2C%200%2C%200%2C%200)%3B" target="_blank">运行代码</a></p>
<h3 id="模块">模块</h3><p>模块是Javascript中非常受欢迎的一个补充，我认为它是ES6中非常值得挖掘的一个特性。<br>现如今，任何重要的JS项目都会使用某种模块系统-可能是“暴露型模块模式”或者更广泛的AMD和Common.js。但是，浏览器是没有任何模块系统的特性的，总是需要为AMD或CommonJS模块构建加载模块，处理这些的工具包括RequireJS，Browserify和Webpack。</p>
<p>ES6规范中同时包含了模块中的语法和加载机制。如果你想要在以后使用模块，应该使用下面的语法。现代的构建工具可以通过插件支持这种格式，所以我们可以尽管去使用它。（不用担心，我们在后面的“Transpilation”章节中会讨论这个问题）。</p>
<p>现在，在ES6的模块语法中，模块被设计成使用export和import两个关键字，我们来看看示例中的两个模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">exprot <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum, pi&#125; <span class="keyword">from</span> <span class="string">"lib/math"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2π = '</span> + sum(pi, pi));</span><br></pre></td></tr></table></figure></p>
<p>如你所见，代码中有多个export语句。每一个都必须显式地声明输出的值，在这个例子中，就是function和var。</p>
<p>示例中的import语句使用了一个语法（类似于解构）来显式地定义了输出的内容。要将整个模块一起输出，可以使用通配符“*”，结合as关键字给模块一个本地名称。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">"lib/math"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2π = '</span> + math.sum(math.pi, math.pi));</span><br></pre></td></tr></table></figure></p>
<p>模块系统有一个默认模块，它也可以是函数。要导出模块内的默认值，需要提供一个本地名称：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/my-fn.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'echo echo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> doSomething <span class="keyword">from</span> <span class="string">'lib/my-fn.js'</span>;</span><br><span class="line">doSomething();</span><br></pre></td></tr></table></figure></p>
<p>注意：import语句是同步的，但是它会等到所有依赖的加载完毕才会执行。</p>
<h3 id="Classes">Classes</h3><p>类是ES6中讨论得很多的一个特性。一些人类违反了JS的原型性质，而其他人觉得这降低了初学者和来自其他开发语言的开发者的入门门槛，并且能够帮助他们编写大规模应用。无论如何，它都是ES6中的一部分，我们简单地介绍一下。<br>我们通过class和constructor关键字构建类，下面是一个简短的示例：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Vehicle&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.kind = <span class="string">'vehicle'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">let</span> myVehicle = <span class="keyword">new</span> Vehicle(<span class="string">'rocky'</span>);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=true&spec=false&code=class%20Vehicle%20%7B%0A%20%20%20%20constructor(name)%20%7B%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%3B%0A%20%20%20%20%20%20%20%20this.kind%20%3D%20'vehicle'%3B%0A%20%20%20%20%7D%0A%20%20%20%20getName()%20%7B%0A%20%20%20%20%20%20%20%20return%20this.name%3B%0A%20%20%20%20%7D%20%20%20%0A%7D%0A%0Alet%20myVehicle%20%3D%20new%20Vehicle('rocky')%3B%0A%0Aconsole.log(myVehicle.getName())%3B%0A" target="_blank">运行代码</a></p>
<p>注意：类的定义并不是一个普通的对象，因此类成员之间没有使用逗号来分隔。</p>
<p>从一个类创建实例必须使用new关键字，而从一个基类继承则使用extends：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car extends Vehicle&#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name)</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.kind = <span class="string">'car'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCar = <span class="keyword">new</span> Car(<span class="string">'bumpy'</span>);</span><br><span class="line"></span><br><span class="line">myCar.getName();<span class="comment">// 'bumpy'</span></span><br><span class="line">myCar <span class="keyword">instanceof</span> Car;<span class="comment">// true</span></span><br><span class="line">myCar <span class="keyword">instanceof</span> Vehicle; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=true&spec=false&code=class%20Vehicle%20%7B%0A%20%20%20%20constructor(name)%20%7B%0A%20%20%20%20%20%20%20%20this.name%20%3D%20name%3B%0A%20%20%20%20%20%20%20%20this.kind%20%3D%20'vehicle'%3B%0A%20%20%20%20%7D%0A%20%20%20%20getName()%20%7B%0A%20%20%20%20%20%20%20%20return%20this.name%3B%0A%20%20%20%20%7D%20%20%20%0A%7D%0A%0Aclass%20Car%20extends%20Vehicle%20%7B%0A%20%20%20%20constructor(name)%20%7B%0A%20%20%20%20%20%20%20%20super(name)%3B%0A%20%20%20%20%20%20%20%20this.kind%20%3D%20'car'%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20myCar%20%3D%20new%20Car('bumpy')%3B%0A%0Aconsole.log(myCar.getName())%3B%0Aconsole.log(myCar%20instanceof%20Car)%3B%0Aconsole.log(myCar%20instanceof%20Vehicle)%3B" target="_blank">运行代码</a></p>
<p>在派生类中，可以使用super关键字来访问基类的构造函数或方法：<br>1、要访问基类构造函数，使用super()<br>2、要访问基类中的方法，是用super.getName()</p>
<p>类还有更多的用法，如果想要深入地学习这方面，可以看看<a href="http://www.2ality.com/2015/02/es6-classes-final.html" target="_blank" rel="external">Classes in ECMAScript6</a></p>
<h3 id="Symbol">Symbol</h3><p>Symbol是一种新的原始数据类型，和Number、String一样。我们可以使用symbol来给对象创建唯一的ID或唯一的常量。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONSTANT = Symbol()<span class="comment">;</span></span><br><span class="line">let obj = &#123;&#125;<span class="comment">;</span></span><br><span class="line">obj[MY_CONSTANT] = 1<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>注意：Object.getOwnPropertyNames方法不会返回Symbol生成键值，在for..in循环中，Object.keys()和JSON.stringify()也是不可见的，这是与普通的字符串key值的区别所在。我们可以通过Object.getOwnPropertySymbols()获取对象中的symbol数组。</p>
<p>因为不可变的特点，Symbols常常与const一起配合使用：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CHINESE = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> ENGLISH = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> SPANISH = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(language)&#123;</span><br><span class="line">    <span class="keyword">case</span> CHINESE:</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ENGLISH:</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPANISH:</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以给Symbol一段字符串来描述，虽然无法通过字符串来访问symbol本身，但是调试的时候很有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CONST_1 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"><span class="keyword">const</span> CONST_2 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> CONST_1 = <span class="string">'symbol'</span>;<span class="comment">// true</span></span><br><span class="line">CONST_1 == CONST_2;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>想要学习更多的symbol内容可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">symbol primitive</a></p>
<h3 id="Transpilation">Transpilation</h3><p>现在我们可以使用ES6来写代码了。前面介绍中提到的浏览器还没有广泛地支持ES6的特性，而且支持性各不相同。你的用户使用的浏览器很有可能不完全懂得解析ES6代码。所以我们要将这些代码转换成上一个版本的Javascript（ES5），它们可以很好地运行在现代浏览器上，这种转换通常被称为Transpilation。在浏览器支持ES6之前，都需要在我们的应用程序中做这一项转换。</p>
<h4 id="开始">开始</h4><p>转换代码并不困难，可以直接通过命令行转换代码，或者在Grunt和Gulp中作为一个Task包含在插件里面。有很多转换代码的方案，比如Babel，Traceur和TypeScript。可以看看这个使用Babel的例子<a href="http://babeljs.io/docs/setup/" target="_blank" rel="external">many ways to start using ES6</a>，很多ES6的特性都会进行处理。</p>
<p>那我们如何使用ES6呢？首先，根据你想要使用的ES6特性和你需要支持的浏览器或运行环境（比如Node.js）,在你的工作流中结合一个编译转换器。如果你希望的话，还有一些监视文件变化和浏览器实时刷新的插件来让你体验无缝的编码。<br>如果是从头开始，你可能只是想要使用命令行来转换代码（查看例子<a href="https://babeljs.io/docs/usage/cli/" target="_blank" rel="external">Babel CLI documentation</a>）。如果你已经使用过grunt或gulp之类的工具，你可以添加一个比如<a href="https://www.npmjs.com/package/gulp-babel" target="_blank" rel="external">gulp-babel</a>的插件，或者Webpack中的<a href="https://github.com/babel/babel-loader" target="_blank" rel="external">babel-loader</a>插件。对于Grunt，有一个<a href="https://github.com/babel/grunt-babel" target="_blank" rel="external">grunt-babel</a>，还有很多其他的<a href="http://gruntjs.com/plugins?q=es6" target="_blank" rel="external">ES6-related plugins</a>。对于使用Browserify的开发者，可以看看<a href="https://github.com/babel/babelify" target="_blank" rel="external">babelify</a>。</p>
<p>很多特性被转换成ES5的兼容性代码后，并不会有很大的开销，通过编译器提供的临时性方案会有一点点的性能损耗。你可以通过各种交互环境（也称作RELPs）来看看使用ES6代码和编译后的代码是什么样的：<br>1、Traceur：<a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">website</a>,<a href="https://google.github.io/traceur-compiler/demo/repl.html" target="_blank" rel="external">REPL</a><br>2、Babel：<a href="https://babeljs.io/" target="_blank" rel="external">website</a>,<a href="https://babeljs.io/repl/" target="_blank" rel="external">REPL</a><br>3、TypeScript：<a href="http://www.typescriptlang.org/" target="_blank" rel="external">website</a>,<a href="http://www.typescriptlang.org/Playground" target="_blank" rel="external">REPL</a><br>4、<a href="https://github.com/richgilbank/Scratch-JS" target="_blank" rel="external">ScratchJS</a>（chrome插件）</p>
<p>注意，TypeScript并不完全是一个转换器，它是强类型的Javascript的超集，可以编译成Javascript，它和其他转换器一样，支持很多ES6特性。</p>
<h4 id="究竟如何使用？">究竟如何使用？</h4><p>通常来说，一些ES6的特性可以自由地使用，比如模块、箭头函数，不定参数和类。这些特性不会用太多开销，就可以转换成ES5代码。而Array、String和Math对象上和原型上的方法（比如Array.from等等）需要所谓的“polyfills”。Polyfills是对那些浏览器还没有原生支持的特性的一个临时方案。你可以首先加载polyfills，如果浏览器有此函数，代码就会正常运行，Babel和Traceur都会提供类似的polyfills。</p>
<p>可以查看<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES6兼容性表</a>来看看转换器和浏览器对ES6新特性的支持情况。令人激动的是，在写这篇文章的时候，最新的浏览器已经支持了所有ES6特性的55%到70%。Microsoft Edge，Google Chrome和Mozilla Firefox相互竞争，这对整个Web的发展有很大的意义。</p>
<p>就我个人而言，我发现能够很简单地使用ES6中的新特性，比如模块，箭头函数和不定参数等等是一种解脱，也是对自己编码的一个显著的提升。现在我很享受使用ES6写代码，然后将其转换成ES5代码。ES6的优点随着时间的增长会越来越明显。</p>
<h4 id="下一步呢？">下一步呢？</h4><p>只要安装了一个转换器，就可以开始使用一些小的特性，比如let和箭头函数。记住，已经编写好的ES5代码，转换器会原封不动地保留下来。当你使用ES6去优化你的代码，慢慢地喜欢用它，你就可以逐步将越来越多的ES6特性应用到代码中。也许有一些代码会有新的模块或类语法，但是我保证一切都会越来越好的！</p>
<p>除了文章中提到的特性，还有更多的ES6的东西没有被提到，比如Map，Set，标签模板字符串，生成器，Proxy和Promise，如果你想知道请关注后续的文章。另外，如果想要深入学习，我推荐<a href="http://exploringjs.com/" target="_blank" rel="external">Exploring ES6</a>这本书，书里面提到了所有的ES6特性。</p>
<h3 id="最后的思考">最后的思考</h3><p>通过使用转换器，所有的代码实际上是转换成了ES5。而浏览器一直在添加新特性，所以，即便浏览器完全支持某个特定的ES6特性，最后还是运行ES5兼容版本的代码，这样<a href="http://kpdecker.github.io/six-speed/" target="_blank" rel="external">可能表现会更糟糕</a>。你可以期待，在你需要兼容的浏览器和运行环境里，所有的ES6特性最终都会被支持。但是在那之前，我们需要管理好这些ES6特性的支持情况，选择性地禁用某些ES6特性来减少转换成ES5代码后带来的不必要的开销。知道了这些，你就可以决定是否要使用ES6中的特性.。</p>
]]></content>
    <summary type="html">
    <![CDATA[你可能已经听说过EMCAScript6（ES6）了，这是下一个版本的Javascript，它包含了一些很棒的新特性。这些特性拥有不同程度的复杂性，对于简单的脚本和复杂的应用程序都非常的有用。本文将盘点一些ES6的新特性，这些特性都可以用在你日常的编码中。请注意，只有现代浏览器才能支持这些新的ES6特性，虽然浏览器的支持各不相同。如果你需要兼容那些不支持ES6新特性的旧浏览器，我也会谈谈关于这方面的解决方案。]]>
    
    </summary>
    
      <category term="ES6" scheme="http://luopq.com/tags/ES6/"/>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="翻译" scheme="http://luopq.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Javascript" scheme="http://luopq.com/categories/Javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo技巧收集 - 不定期更新]]></title>
    <link href="http://luopq.com/2016/01/17/hexo-tips/"/>
    <id>http://luopq.com/2016/01/17/hexo-tips/</id>
    <published>2016-01-17T09:08:34.000Z</published>
    <updated>2016-01-23T13:57:56.639Z</updated>
    <content type="html"><![CDATA[<h3 id="不处理source目录的个别文件">不处理source目录的个别文件</h3><p>有时候我们要写一些Demo一起放到博客上去，默认情况下，Hexo也会将这部分Demo进行处理，导致这些Demo页面渲染上了博客主题，如何不处理这些Demo页面呢? </p>
<p>假设你的Source文件夹里面有个Demo目录，要忽略Demo目录下的所有html页面，可以通过在_config.yml设置skip_render来忽略的目录，具体如下：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">skip_render</span>: <span class="string">Demo/*.html</span></span><br></pre></td></tr></table></figure></p>
<p>文件匹配是基于正则匹配的，更复杂的情况如下</p>
<p>1.单个文件夹下全部文件：skip_render: demo/*</p>
<p>2.单个文件夹下指定类型文件：skip_render: demo/*.html </p>
<p>3.单个文件夹下全部文件以及子目录:skip_render: demo/** </p>
<p>4.多个文件夹以及各种复杂情况：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">    -<span class="ruby"> <span class="string">'demo/*.html'</span></span><br><span class="line"></span>    -<span class="ruby"> <span class="string">'demo/**'</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="根据内容修改主题模板">根据内容修改主题模板</h3><p>写博客的时候，我们偶尔会加上一些统一的备注或补充，比如转载请注明原文地址等等。看下面的例子，Hexo生成的新博客的默认内容是：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">title</span>: <span class="string">标题</span></span><br><span class="line"><span class="attribute">date</span>: <span class="string">2016-01-23 17:08:34</span></span><br><span class="line"><span class="attribute">tags</span>: <span class="string">[Hexo,Tips]</span></span><br><span class="line"><span class="attribute">categories</span>: <span class="string">Hexo</span></span><br></pre></td></tr></table></figure></p>
<p>我们选中的主题会根据这个内容进行渲染，假设我们要在文章前开头注明一些额外信息，可以增加内容如下：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">title</span>: <span class="string">标题</span></span><br><span class="line"><span class="attribute">date</span>: <span class="string">2016-01-23 17:08:34</span></span><br><span class="line"><span class="attribute">tags</span>: <span class="string">[Hexo,Tips]</span></span><br><span class="line"><span class="attribute">categories</span>: <span class="string">Hexo</span></span><br><span class="line"><span class="attribute">extraInfo</span>: <span class="string">这里是额外信息</span></span><br></pre></td></tr></table></figure></p>
<p>然后找到我们主题目录下相关的模板文件，比如这里我们找到的一个swig文件内容如下：<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post-body"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="title">span</span> <span class="attribute">itemprop</span>=<span class="value">"articleBody"</span>&gt;</span></span><span class="expression">&#123;&#123; <span class="variable">post.content</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面是省略后的模板文件，然后我们可以依葫芦画瓢地添加上自己写的额外信息（如果还是不知道模板的语法，可以swig模板引擎的语法），修改如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"post-body"</span>&gt;</span></span><br><span class="line">	</span><span class="template_tag">&#123;% <span class="keyword">if</span> page.extraInfo %&#125;</span><span class="xml"></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="variable">&#123;&#123; page.extraInfo &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">	</span><span class="template_tag">&#123;% <span class="keyword">endif</span> %&#125;</span><span class="xml"></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="title">span</span> <span class="attribute">itemprop</span>=<span class="value">"articleBody"</span>&gt;</span></span><span class="variable">&#123;&#123; post.content &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>增加了渲染extraInfo的代码，这里只是简单的进行了if判断，当然有更复杂的for，elseif等需求，大家可以查查相关的语法。<br>这样修改后，我们就可以定制我们的页面内容了。</p>
]]></content>
    <summary type="html">
    <![CDATA[一些平时Hexo技巧的收集，不定期更新]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://luopq.com/tags/Hexo/"/>
    
      <category term="Tips" scheme="http://luopq.com/tags/Tips/"/>
    
      <category term="Hexo" scheme="http://luopq.com/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS代码重构与优化之路]]></title>
    <link href="http://luopq.com/2016/01/05/css-optimize/"/>
    <id>http://luopq.com/2016/01/05/css-optimize/</id>
    <published>2016-01-04T16:03:03.000Z</published>
    <updated>2016-01-04T16:19:39.000Z</updated>
    <content type="html"><![CDATA[<p>写CSS的同学们往往会体会到，随着项目规模的增加，项目中的CSS代码也会越来越多，如果没有及时对CSS代码进行维护，CSS代码不断会越来越多。CSS代码交错复杂，像一张庞大的蜘蛛网分布在网站的各个位置，你不知道修改这行代码会有什么影响，所以如果有修改或增加新功能时，开发人员往往不敢去删除旧的冗余的代码，而保险地增加新代码，最终的坏处就是项目中的CSS会越来越多，最终陷入无底洞。</p>
<h3 id="CSS代码重构的目的">CSS代码重构的目的</h3><p>我们写CSS代码时，不仅仅只是完成页面设计的效果，还应该让CSS代码易于管理，维护。我们对CSS代码重构主要有两个目的：<br>1、提高代码性能<br>2、提高代码的可维护性</p>
<h4 id="提高代码性能">提高代码性能</h4><p>提高CSS代码性能主要有两个点：<br>1、提高页面的加载性能<br>提高页面的加载性能，简单说就是减小CSS文件的大小，提高页面的加载速度，尽可以的利用http缓存<br>2、提高CSS代码性能<br>不同的CSS代码，浏览器对其解析的速度也是不一样的，如何提高浏览器解析CSS代码的速度也是我们要考虑的</p>
<h4 id="提高代码的可维护性">提高代码的可维护性</h4><p>提高CSS代码的可维护性主要是体现在下面几点：<br>1、可重用性<br>一般来说，一个项目的整体设计风格是一致的，页面中肯定有几个风格一致但有些许不同的模块，如何在尽可能多地重用CSS代码，尽可能少地增加新代码，这是CSS代码中非常重要的一点。如果CSS代码的重用性高，我们可能只需要写一些不一样的地方，对页面性能和可维护性、提高开发效率都有很大的帮助。</p>
<p>2、可扩展性<br>如果产品增加了某个功能，我们应该保证新增加的CSS代码不会影响到旧的CSS代码和页面，并且尽可能少地增加新代码而重用旧代码。</p>
<p>3、可修改性<br>如果某个模块产品经理觉得要修改样式，或者要删掉它，如果没有规划好相应的CSS代码，过了一段时间之后，开发人员可能已经不记得这段代码作用了几个地方，不敢修改或删除它，这样下去CSS代码也就越来越多，影响了页面的性能，还造成了代码的复杂度。</p>
<h3 id="CSS代码重构的基本方法">CSS代码重构的基本方法</h3><p>前面说到了CSS代码重构的目的，现在我们来说说一些如何达到这些目的的一些基本方法，这些方法都是易于理解，容易实施的一些手段，大家平时可能也不知不觉地在使用它。</p>
<h4 id="提高CSS性能的手段">提高CSS性能的手段</h4><p>首先说说如何提高CSS性能，根据页面的加载性能和CSS代码性能，主要总结有下面几点：<br>1、尽量将样式写在单独的css文件里面，在head元素中引用<br>有时候为了图方便或者快速搞定功能，我们可能会直接将样式写在页面的style标签或者直接内联在元素上，这样虽然简单方便，但是非常不利于日后的维护。将代码写成单独的css文件有几点好处：<br>（1）内容和样式分离，易于管理和维护<br>（2）减少页面体积<br>（3）css文件可以被缓存、重用，维护成本降低</p>
<p>2、不使用@import<br>这条手段已经是众所周知，这里简单提一下，@import影响css文件的加载速度</p>
<p>3、避免使用复杂的选择器，层级越少越好<br>有时候项目的模块越来越多，功能越来越复杂，我们写的CSS选择器会内套多层，越来越复杂。<br>建议选择器的嵌套最好不要超过三层，比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.header</span> <span class="class">.logo</span> <span class="class">.text</span><span class="rules">&#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以优化成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.haeder</span> <span class="class">.logo-text</span><span class="rules">&#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>简洁的选择器不仅可以减少css文件大小，提高页面的加载性能，浏览器解析时也会更加高效，也会提高开发人员的开发效率，降低了维护成本。</p>
<p>4、精简页面的样式文件，去掉不用的样式<br>很多时候，我们会把所有的样式文件合并成一个文件，但是这样有一个问题：很多其他页面的CSS同时引用到当前页面中，而当前页面并没有用到它们，这种情况会造成两个问题：<br>（1）样式文件偏大，影响加载速度<br>（2）浏览器会进行多余的样式匹配，影响渲染时间。<br>正确的处理方法是根据当前页面需要的css去合并那些当前页面用到的CSS文件。<br>PS：合并成一个文件有一个优点：样式文件会被浏览器缓存，进入到其他页面样式文件不用再去下载。这条规则应根据场景来区别对待，如果是大项目，应该合并成不同的样式文件，如果是简单的项目，建议合并成一个文件即可。如果无法确认项目规模，建议分开成不同的样式文件，日后要合并也比较方便。</p>
<p>5、利用CSS继承减少代码量<br>我们知道有一部分CSS代码是可以继承的，如果父元素已经设置了该样式，子元素就不需要去设置该样式，这个也是提高性能的行之有效的方法。<br>常见的可以继承的属性比如：<br>color，font-size，font-family等等<br>不可继承的比如：<br>position，display，float等</p>
<p>大家可以查看<a href="http://www.css88.com/book/css/properties/layout/float.htm" target="_blank" rel="external">CSS参考手册</a></p>
<h4 id="提高可维护性的方法">提高可维护性的方法</h4><p>提高CSS代码的可维护性，简单的说就是要让开发人员易于理解CSS代码，容易去修改它，不会破坏原有的功能。下面说说一些常用的手段。<br>1、命名与备注<br>命名是提高代码可读性的第一步，也是及其重要的一步。很多人都有这样的体会：命名是写代码中最让程序员头疼的事情之一，尤其是对母语非英语的开发人员来说，要找一个合适贴切的名字并不容易。提高自己命名的能力，可以多看看别人的代码。下面是CSS中的一些命名相关的建议：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">头：<span class="tag">header</span></span><br><span class="line">内容：<span class="attribute">content</span>/container</span><br><span class="line">尾：<span class="tag">footer</span></span><br><span class="line">导航：<span class="tag">nav</span></span><br><span class="line">侧栏：sidebar</span><br><span class="line">栏目：column</span><br><span class="line">页面外围控制整体佈局宽度：wrapper</span><br><span class="line">左右中：<span class="attribute">left</span> <span class="attribute">right</span> center</span><br><span class="line">登录条：loginbar</span><br><span class="line">标志：logo</span><br><span class="line">广告：banner</span><br><span class="line">页面主体：main</span><br><span class="line">热点：hot</span><br><span class="line">新闻：news</span><br><span class="line">下载：download</span><br><span class="line">子导航：subnav</span><br><span class="line">菜单：<span class="tag">menu</span></span><br><span class="line">子菜单：submenu</span><br><span class="line">搜索：search</span><br><span class="line">友情链接：friendlink</span><br><span class="line">页脚：<span class="tag">footer</span></span><br><span class="line">版权：copyright</span><br><span class="line">滚动：scroll</span><br><span class="line">内容：<span class="attribute">content</span></span><br><span class="line">标签：tags</span><br><span class="line">文章列表：list</span><br><span class="line">提示信息：msg</span><br><span class="line">小技巧：tips</span><br><span class="line">栏目标题：title</span><br><span class="line">加入：joinus</span><br><span class="line">指南：guide</span><br><span class="line">服务：service</span><br><span class="line">注册：regsiter</span><br><span class="line">状态：status</span><br><span class="line">投票：vote</span><br><span class="line">合作伙伴：partner</span><br><span class="line">导航：<span class="tag">nav</span></span><br><span class="line">主导航：mainnav</span><br><span class="line">子导航：subnav</span><br><span class="line">顶导航：topnav</span><br><span class="line">边导航：sidebar</span><br><span class="line">左导航：leftsidebar</span><br><span class="line">右导航：rightsidebar</span><br><span class="line">菜单：<span class="tag">menu</span></span><br><span class="line">子菜单：submenu</span><br><span class="line">标题: title</span><br><span class="line">摘要: summary</span><br></pre></td></tr></table></figure></p>
<p>2、提取重复样式<br>这一个方法很容易理解，简单说就是提取相同的样式成为一个单独的类再引用，这样不仅可以精简CSS文件大小，而且CSS代码变少，更易于重用和维护。例如下面的例子：<br>原来的代码是这样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.about-title</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto <span class="number">6rem</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">letter-spacing</span>:<span class="value"> <span class="number">4px</span></span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2rem</span></span></span>; </span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.achieve-title</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto <span class="number">6rem</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">letter-spacing</span>:<span class="value"> <span class="number">4px</span></span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2rem</span></span></span>; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这两个样式的区别在于文字颜色的不同，我们可以将其公共的样式提取出来，然后再分别设置其不同的样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.column-title</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto <span class="number">6rem</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">letter-spacing</span>:<span class="value"> <span class="number">4px</span></span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">2rem</span></span></span>; </span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.about</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.achieve</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>提取公用的部分，然后在页面上分别引用column-title和about等，这样代码更简洁，维护起来也更方便了。这个例子非常简单，实际上项目中可能有更复杂的情况，总之就要要尽可能的DRY，尽可能的提取重复的东西。</p>
<p>3、书写顺序<br>这个书写顺序指的是各个样式的书写顺序，下面是推荐的CSS书写顺序<br>（1）位置属性(position, top, right, z-index, display, float等)<br>（2）大小(width, height, padding, margin)<br>（3）文字系列(font, line-height, letter-spacing, color- text-align等)<br>（4）背景(background, border等)<br>（5）其他(animation, transition等)<br>书写顺序不一定非得按照上面的推荐来进行，而是根据你自己的习惯，但是最好能保证前后的习惯一致的，或者团队应该有一个共同的代码规范去遵守，这样后期维护起来也会方便许多。</p>
<p>以上是我个人总结的一些简单的写好和重构CSS代码的方法，大家当然不必拘泥于此，有不同的意见和建议欢迎进行交流！</p>
<h3 id="CSS方法论">CSS方法论</h3><p>什么是CSS方法论呢？简单地说就是一些同行为了提高CSS的可维护性、提出的一些编写CSS代码的规范和方法。他们提出了一些概念，这些概念可能听起来很高大上，但是实际你平时可能不知不觉也会用到这些所谓的CSS方法论。下面我简单地介绍下几个比较常见的CSS方法论。</p>
<h4 id="OOCSS">OOCSS</h4><p>OOCSS是（Object Oriented CSS），顾名思义就是面向对象的CSS。<br>OOCSS主要有两个原则：<br>1、结构和样式分离<br>我们平时一定遇到过这种情况，比如一个页面存在着多个不同功能的按钮，这些按钮的形状大小都差不多，但是根据不同的功能会有不同的颜色或背景来加以区分。如果不进行结构和样式分离，我们的CSS代码可能是这样的<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.btn-primary</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">5px</span> <span class="number">3px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#000</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.btn-delete</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">5px</span> <span class="number">3px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value">red</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这两个或者可能更多的按钮拥有一些不同的样式，但是它们同时拥有相同的大小样式等，我们将其抽象的部分提取出来，结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.btn</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">5px</span> <span class="number">3px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.primary</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value">red</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.delete</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value">red</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样提取公用的样式出来，然后按钮同时引用btn和primary等。这种做法除了减少重复的代码精简CSS之外，还有一个好处是复用性，如果需要增加其他额外的按钮，只需要编写不同的样式，和btn配合使用即可。</p>
<p>（2）容器和内容分离<br>我们平时写代码一定写过这样代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.content</span> <span class="tag">h3</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">20px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#333</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样的代码就是内容依赖于容器，没有分离的代码，也就是说h3的样式依赖于.content容器，如果其他地方要用到相同的样式，但是它的容器却不是.content，那你可能就是要再写一遍.something h3。<br>所以OOCSS推荐分离容器和内容，可以修改成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.title</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">20px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#333</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>关于这一点，我个人建议要分情况来看，像前面这个例子，它适合样式和容器分离。但是比如下面这种情况：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.menu</span> <span class="tag">li</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">12px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这种ul，li列表的样式，我觉的就按照我们原先的做法就可以，不一定非得给一个类给li来设定样式，即<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.menu-item</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">12px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样页面的li标签需要引用menu-item类。<br>当然采用哪一种方式更好我也不却确定，我自己比较喜欢.menu li的写法，大家自行思考。<br>这就是OOCSS的两个基本原则，这里只是简单介绍OOCSS，各位如果有兴趣的话请自行Google查找相关资料。</p>
<h4 id="SMACSS">SMACSS</h4><p>SMACSS是什么呢，它的全称是Scalable and Modular Architecture for CSS。简单说就是可扩展和模块化的CSS架构。<br>SMACSS将样式分成5种类型：Base，Layout，Module，State，Theme，我们简单来说说每一种类型分别指什么。<br>1、Base<br>基础样式表，定义了基本的样式，我们平时写CSS比如reset.css就是属于基础样式表，另外我认为清除浮动，一些动画也可以归类为基础样式。</p>
<p>2、Layout<br>布局样式，用于实现网页的基本布局，搭起整个网页的基本骨架。</p>
<p>3、Module<br>网页中不同的区域有这个不同的功能，这些功能是相对独立的，我们可以称其为模块。模块是独立的，可重用的组件，它们不依赖于布局组件，可以安全的删除修改而不影响其他模块。</p>
<p>4、State<br>状态样式，通常和js一起配合使用，表示某个组件或功能不同的状态，比如菜单选中状态，按钮不可用状态等。<br>关于状态样式，我个人觉得要分情况进行讨论：<br>（1）不同组件的同一状态的样式是一样的，比如头部的导航菜单的选中状态样式和侧栏的菜单选中状态样式是一样的，我认为这部分状态样式可以归类为State<br>（2）不同组件的统一状态的样式是不一样的，即两个地方的菜单虽然都是选中状态，但是他们却又不同的选中样式，这部分样式不应该被认为是State类型，而是应该放在其组件对应的Module中。</p>
<p>5、Theme<br>皮肤样式，对于可更换皮肤的站点来说，这个是很有必要的，分离了结构和皮肤，根据不同的皮肤应用不同的样式文件。</p>
<h4 id="BEM">BEM</h4><p>BEM是Block，Element，Modifier的缩写。下面分别来介绍一下这三个概念：<br>（1）Block：在BEM的理论中，一个网页是由block组成的，比如头部是个block，内容是block，logo也是block，一个block可能由几个子block组成。<br>（2）Element：element是block的一部分，具有某种功能，element依赖于block，比如在logo中，img是logo的一个element，在菜单中，菜单项是菜单的一个element<br>（3）Modifier：modifier是用来修饰block或者element的，它表示block或者element在外观或行为上的改变<br>我们通过BEM命名法写样式如下：<br>.block{}<br>.block-element{}<br>.block-modifier{}<br>.block-element-modifier{}<br>BEM将页面解析为block和element，然后根据不同的状态使用modifier来设置样式。<br>我对BEM的思想理解可能不到位，对BEM的看法主要是由两点：<br>（1）页面CSS模块化，每个block就是一个模块，模块间相互独立<br>（2）多级的class命名，避免选择器的嵌套结构</p>
<h4 id="关于CSS方法论">关于CSS方法论</h4><p>上面提到的这些CSS方法论，大家看了就会发现，它们其实有很多思想是相同的，比如：<br>1、选择器的嵌套的优化<br>2、CSS代码模块化<br>3、抽象CSS代码<br>…<br>这些方法论，我们学习的时候，最重要的是去理解其思想，不一定非得照搬它的实现形式，多种方法结合使用。</p>
<h3 id="我自己总结的方法">我自己总结的方法</h3><p>谈了这么多，下面来说说我自己总结的写CSS代码的一些关键点。<br>1、写代码之前：从PSD文件出发<br>当我们拿到设计师给的PSD时，首先不要急于写CSS代码，首先对整个页面进行分析，主要关注点是下面几个：<br>（1）页面分成了几个模块，哪些模块是公用的，常见的比如头部和底部，还有一些菜单栏等等<br>（2）分析每一个模块都有什么样式，提取出公用的样式，注意公用样式是全局公用（整个页面公用）还是局部公用（模块内公用），公用样式包括公用的状态样式，比如公用的选中状态，禁用状态等等。<br>2、开始写代码<br>根据对PSD文件的分析，我们就可以开始着手写代码，我比较推荐SMACSS将样式分成不同类型的做法：<br>（1）第一步是搭好页面的骨架，也就是base样式，layout样式。<br>（2）第二步就是依次实现不同的模块，在这里我推荐BEM的命名思想，但是可以嵌套一到两层的选择器结构<br>3、优化代码<br>我相信当我们完成基本的页面效果后，还是会存在着一些重复的或者不够简洁的代码，这时候就是要去优化这些代码，主要是在提取重复代码，尽可能地精简代码。</p>
<p>关于CSS代码的优化，我相信大家有很多自己的看法，欢迎交流和讨论！</p>
]]></content>
    <summary type="html">
    <![CDATA[写CSS的同学们往往会体会到，随着项目规模的增加，项目中的CSS代码也会越来越多，如果没有及时对CSS代码进行维护，CSS代码不断会越来越多。CSS代码交错复杂，像一张庞大的蜘蛛网分布在网站的各个位置，你不知道修改这行代码会有什么影响，所以如果有修改或增加新功能时，开发人员往往不敢去删除旧的冗余的代码，而保险地增加新代码，最终的坏处就是项目中的CSS会越来越多，最终陷入无底洞。]]>
    
    </summary>
    
      <category term="CSS" scheme="http://luopq.com/tags/CSS/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript操作DOM常用API总结]]></title>
    <link href="http://luopq.com/2015/11/30/javascript-dom/"/>
    <id>http://luopq.com/2015/11/30/javascript-dom/</id>
    <published>2015-11-30T15:46:59.000Z</published>
    <updated>2015-12-01T13:47:15.056Z</updated>
    <content type="html"><![CDATA[<p>文本整理了javascript操作DOM的一些常用的api，根据其作用整理成为创建，修改，查询等多种类型的api，主要用于复习基础知识，加深对原生js的认识。</p>
<h3 id="基本概念">基本概念</h3><p>在讲解操作DOM的api之前，首先我们来复习一下一些基本概念，这些概念是掌握api的关键，必须理解它们。</p>
<h4 id="Node类型">Node类型</h4><p>DOM1级定义了一个Node接口，该接口由DOM中所有节点类型实现。这个Node接口在JS中是作为Node类型实现的。在IE9以下版本无法访问到这个类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法。<br>Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，具体如下：<br>Node.ELEMENT_NODE:1<br>Node.ATTRIBUTE_NODE:2<br>Node.TEXT_NODE:3<br>Node.CDATA_SECTION_NODE:4<br>Node.ENTITY_REFERENCE_NODE:5<br>Node.ENTITY_NODE:6<br>Node.PROCESSING_INSTRUCTION_NODE:7<br>Node.COMMENT_NODE:8<br>Node.DOCUMENT_NODE:9<br>Node.DOCUMENT_TYPE_NODE:10<br>Node.DOCUMENT_FRAGMENT_NODE:11<br>Node.NOTATION_NODE:12<br>假设我们要判断一个Node是不是元素，我们可以这样判断<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType == <span class="number">1</span>)&#123;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"Node is a element"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些Node类型中，我们最常用的就是element，text，attribute，comment，document，document_fragment这几种类型。<br>我们简单来介绍一下这几种类型：</p>
<h4 id="Element类型">Element类型</h4><p>Element提供了对元素标签名，子节点和特性的访问，我们常用HTML元素比如div，span，a等标签就是element中的一种。Element有下面几条特性：<br>（1）nodeType为1<br>（2）nodeName为元素标签名，tagName也是返回标签名<br>（3）nodeValue为null<br>（4）parentNode可能是Document或Element<br>（5）子节点可能是Element，Text，Comment，Processing_Instruction，CDATASection或EntityReference</p>
<h4 id="Text类型">Text类型</h4><p>Text表示文本节点，它包含的是纯文本内容，不能包含html代码，但可以包含转义后的html代码。Text有下面的特性：<br>（1）nodeType为3<br>（2）nodeName为#text<br>（3）nodeValue为文本内容<br>（4）parentNode是一个Element<br>（5）没有子节点</p>
<h4 id="Attr类型">Attr类型</h4><p>Attr类型表示元素的特性，相当于元素的attributes属性中的节点，它有下面的特性：<br>（1）nodeType值为2<br>（2）nodeName是特性的名称<br>（3）nodeValue是特性的值<br>（4）parentNode为null</p>
<h4 id="Comment类型">Comment类型</h4><p>Comment表示HTML文档中的注释，它有下面的几种特征：<br>（1）nodeType为8<br>（2）nodeName为#comment<br>（3）nodeValue为注释的内容<br>（4）parentNode可能是Document或Element<br>（5）没有子节点</p>
<h4 id="Document">Document</h4><p>Document表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个页面，它同时也是window对象的一个属性。Document有下面的特性：<br>（1）nodeType为9<br>（2）nodeName为#document<br>（3）nodeValue为null<br>（4）parentNode为null<br>（5）子节点可能是一个DocumentType或Element</p>
<h4 id="DocumentFragment类型">DocumentFragment类型</h4><p>DocumentFragment是所有节点中唯一一个没有对应标记的类型，它表示一种轻量级的文档，可能当作一个临时的仓库用来保存可能会添加到文档中的节点。DocumentFragment有下面的特性：<br>（1）nodeType为11<br>（2）nodeName为#document-fragment<br>（3）nodeValue为null<br>（4）parentNode为null</p>
<p>我们简单地介绍了几种常见的Node类型，要记住，HTML中的节点并不只是包括元素节点，它还包括文本节点，注释节点等等。在这里我们只是简单地说明了几种常见的节点，想要进一步学习的同学可以查找一下相关资料。</p>
<h3 id="节点创建型api">节点创建型api</h3><p>在这里，我将常用的DOM操作api进行分类，首先要介绍的是创建型的api。这一类型的api，简而言之就是用来创建节点的。</p>
<h4 id="createElement">createElement</h4><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签。<br>使用如下：<br><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">div</span> = document.createElement(<span class="variable">"div"</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p>
<h4 id="createTextNode">createTextNode</h4><p>createTextNode用来创建一个文本节点，用法如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"一个TextNode"</span>);</span><br></pre></td></tr></table></figure></p>
<p>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中</p>
<h4 id="cloneNode">cloneNode</h4><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> parent</span> = document.getElementById(<span class="string">"parentElement"</span>); </span><br><span class="line"><span class="variable"><span class="keyword">var</span> parent2</span> = parent.cloneNode(<span class="literal">true</span>);<span class="comment">// 传入true</span></span><br><span class="line">parent2.id = <span class="string">"parent2"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码通过cloneNode复制了一份parent元素，其中cloneNode的参数为true，表示parent的子节点也被复制，如果传入false，则表示只复制了parent节点。<br>我们看看这个<a href="http://runjs.cn/detail/s2yelqet" target="_blank" rel="external">例子</a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    我是父元素的文本</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">        我是子元素</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;button id=<span class="string">"btnCopy"</span>&gt;复制&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">parent</span> = document.getElementById(<span class="string">"parent"</span>);</span><br><span class="line">document.getElementById(<span class="string">"btnCopy"</span>).onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> parent2 = <span class="keyword">parent</span>.cloneNode(<span class="keyword">true</span>);</span><br><span class="line">	parent2.id = <span class="string">"parent2"</span>;</span><br><span class="line">	document.body.appendChild(parent2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码很简单，主要是绑定button事件，事件内容是复制了一个parent，修改其id，然后添加到文档中。<br>这里有几点要注意：<br>（1）和createElement一样，cloneNode创建的节点只是游离有html文档外的节点，要调用appendChild方法才能添加到文档树中<br>（2）如果复制的元素有id，则其副本同样会包含该id，由于id具有唯一性，所以在复制节点后必须要修改其id<br>（3）调用接收的bool参数最好传入，如果不传入该参数，不同浏览器对其默认值的处理可能不同</p>
<p>除此之外，我们还有一个需要注意的点：<br>如果被复制的节点绑定了事件，则副本也会跟着绑定该事件吗？这里要分情况讨论：<br>（1）如果是通过addEventListener或者比如onclick进行绑定事件，则副本节点不会绑定该事件<br>（2）如果是内联方式绑定比如<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> onclick=<span class="string">"showParent()"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样的话，副本节点同样会触发事件。</p>
<h4 id="createDocumentFragment">createDocumentFragment</h4><p>createDocumentFragment方法用来创建一个DocumentFragment。在前面我们说到DocumentFragment表示一种轻量级的文档，它的作用主要是存储临时的节点用来准备添加到文档中。<br>createDocumentFragment方法主要是用于添加大量节点到文档中时会使用到。假设要循环一组数据，然后创建多个节点添加到文档中，比如<a href="http://runjs.cn/detail/nu4wptvl" target="_blank" rel="external">示例</a><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"list"</span>&gt;&lt;/ul&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">"button"</span> value=<span class="string">"添加多项"</span> id=<span class="string">"btnAdd"</span> /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">"btnAdd"</span>).onclick = function()&#123;</span><br><span class="line">	<span class="keyword">var</span> <span class="keyword">list</span> = document.getElementById(<span class="string">"list"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = 0;i &lt; 100; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">li</span> = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">		<span class="keyword">li</span>.textContent = i;</span><br><span class="line">		<span class="keyword">list</span>.appendChild(<span class="keyword">li</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码将按钮绑定了一个事件，这个事件创建了100个li节点，然后依次将其添加HTML文档中。这样做有一个缺点：每次一创建一个新的元素，然后添加到文档树中，这个过程会造成浏览器的回流。所谓回流简单说就是指元素大小和位置会被重新计算，如果添加的元素太多，会造成性能问题。这个时候，就是使用createDocumentFragment了。<br>DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。我们修改上面的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"btnAdd"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);	</span><br><span class="line">	<span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">	  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">		li.textContent = i;</span><br><span class="line">		fragment.appendChild(li);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list.appendChild(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化后的代码主要是创建了一个fragment，每次生成的li节点先添加到fragment，最后一次性添加到list，大家可以看<a href="http://runjs.cn/detail/nu4wptvl" target="_blank" rel="external">示例</a></p>
<h4 id="创建型API总结">创建型API总结</h4><p>创建型api主要包括createElement，createTextNode，cloneNode和createDocumentFragment四个方法，需要注意下面几点：<br>（1）它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中<br>（2）cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题<br>（3）使用createDocumentFragment来解决添加大量节点时的性能问题</p>
<h3 id="页面修改型API">页面修改型API</h3><p>前面我们提到创建型api，它们只是创建节点，并没有真正修改到页面内容，而是要调用appendChild来将其添加到文档树中。我在这里将这类会修改到页面内容归为一类。<br>修改页面内容的api主要包括：appendChild，insertBefore，removeChild，replaceChild。</p>
<h4 id="appendChild">appendChild</h4><p>appendChild我们在前面已经用到多次，就是将指定的节点添加到调用该方法的节点的子元素的末尾。调用方法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">parent</span><span class="class">.appendChild</span>(<span class="tag">child</span>);</span><br></pre></td></tr></table></figure></p>
<p>child节点将会作为parent节点的最后一个子节点。<br>appendChild这个方法很简单，但是还有有一点需要注意：如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点，也就是说不会同时存在两个该节点在页面上，相当于把这个节点移动到另一个地方。我们来看<a href="http://runjs.cn/detail/kk3bodpw" target="_blank" rel="external">例子</a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"child"</span>&gt;</span><br><span class="line">    要被添加的节点</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    要移动的位置</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;		</span><br><span class="line">&lt;input <span class="property">id</span>=<span class="string">"btnMove"</span> type=<span class="string">"button"</span> value=<span class="string">"移动节点"</span> /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">"btnMove"</span>).onclick = function()&#123;</span><br><span class="line">	var child = document.getElementById(<span class="string">"child"</span>);</span><br><span class="line">	document.getElementById(<span class="string">"parent"</span>).appendChild(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码主要是获取页面上的child节点，然后添加到指定位置，可以看到原本的child节点被移动到parent中了。<br>这里还有一个要注意的点：如果child绑定了事件，被移动时，它依然绑定着该事件。</p>
<h4 id="insertBefore">insertBefore</h4><p>insertBefore用来添加一个节点到一个参照节点之前，用法如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">parentNode</span><span class="class">.insertBefore</span>(<span class="tag">newNode</span>,<span class="tag">refNode</span>);</span><br></pre></td></tr></table></figure></p>
<p>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前<br>我们来看这个<a href="http://runjs.cn/detail/p2rs1tmy" target="_blank" rel="external">例子</a><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    父节点</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;				</span><br><span class="line">        子元素</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">"insertNode"</span> value=<span class="string">"插入节点"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>);</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"insertNode"</span>).onclick = <span class="keyword">function</span>()&#123;</span><br><span class="line">	<span class="keyword">var</span> newNode = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">	newNode.textContent = <span class="string">"新节点"</span></span><br><span class="line">	parent.insertBefore(newNode,child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码创建了一个新节点，然后添加到child节点之前。<br>和appendChild一样，如果插入的节点是页面上的节点，则会移动该节点到指定位置，并且保留其绑定的事件。</p>
<p>关于第二个参数参照节点还有几个注意的地方：<br>（1）refNode是必传的，如果不传该参数会报错<br>（2）如果refNode是undefined或null，则insertBefore会将节点添加到子元素的末尾</p>
<h4 id="removeChild">removeChild</h4><p>removeChild顾名思义，就是删除指定的子节点并返回，用法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> deletedChild</span> = parent.removeChild(node);</span><br></pre></td></tr></table></figure></p>
<p>deletedChild指向被删除节点的引用，它等于node，被删除的节点仍然存在于内存中，可以对其进行下一步操作。<br>注意：如果被删除的节点不是其子节点，则程序将会报错。我们可以通过下面的方式来确保可以删除：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">if(node.parentNode)&#123;</span><br><span class="line">    node<span class="string">.parentNode.removeChild(node)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>通过节点自己获取节点的父节点，然后将自身删除。</p>
<h4 id="replaceChild">replaceChild</h4><p>replaceChild用于使用一个节点替换另一个节点，用法如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">parent</span><span class="class">.replaceChild</span>(<span class="tag">newChild</span>,<span class="tag">oldChild</span>);</span><br></pre></td></tr></table></figure></p>
<p>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p>
<h4 id="页面修改型API总结">页面修改型API总结</h4><p>页面修改型api主要是这四个接口，要注意几个特点：<br>（1）不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置<br>（2）节点本身绑定的事件会不会消失，会一直保留着。</p>
<h3 id="节点查询型API">节点查询型API</h3><p>节点查询型API也是非常常用的api，下面我们分别说明一下每一个api的使用。</p>
<h4 id="document-getElementById">document.getElementById</h4><p>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br>使用这个接口有几点要注意：<br>（1）元素的Id是大小写敏感的，一定要写对元素的id<br>（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素<br>（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p>
<h4 id="document-getElementsByTagName">document.getElementsByTagName</h4><p>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？我们来看看这个<a href="http://runjs.cn/detail/13jvrs9t" target="_blank" rel="external">示例</a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;div1&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;div2&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">		</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"显示数量"</span> <span class="property">id</span>=<span class="string">"btnShowCount"</span>/&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"新增div"</span> <span class="property">id</span>=<span class="string">"btnAddDiv"</span>/&gt;	</span><br><span class="line"></span><br><span class="line">var divList = document.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line">document.getElementById(<span class="string">"btnAddDiv"</span>).onclick = function()&#123;</span><br><span class="line">	var <span class="keyword">div</span> = document.createElement(<span class="string">"div"</span>);</span><br><span class="line">	<span class="keyword">div</span>.textContent =<span class="string">"div"</span> + (divList.<span class="property">length</span>+<span class="number">1</span>);</span><br><span class="line">	document.body.appendChild(<span class="keyword">div</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">document.getElementById(<span class="string">"btnShowCount"</span>).onclick = function()&#123;</span><br><span class="line">        alert(divList.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中有两个按钮，一个按钮是显示HTMLCollection元素的个数，另一个按钮可以新增一个div标签到文档中。前面提到HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。<br>使用document.getElementsByTagName这个方法有几点要注意：<br>（1）如果要对HTMLCollection集合进行循环操作，最好将其长度缓存起来，因为每次循环都会去计算长度，暂时缓存起来可以提高效率<br>（2）如果没有存在指定的标签，该接口返回的不是null，而是一个空的HTMLCollection<br>（3）“*”表示所有标签</p>
<h4 id="document-getElementsByName">document.getElementsByName</h4><p>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br>使用这个接口主要要注意几点：<br>（1）返回对象是一个即时的NodeList，它是随时变化的<br>（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的<br>（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name</p>
<h4 id="document-getElementsByClassName">document.getElementsByClassName</h4><p>这个API是根据元素的class返回一个即时的HTMLCollection，用法如下<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(names);</span><br></pre></td></tr></table></figure></p>
<p>这个接口有下面几点要注意：<br>（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化<br>（2）IE9以下浏览器不支持<br>（3）如果要获取2个以上classname，可传入多个classname，每个用空格相隔，例如<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"test1 test2"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="document-querySelector和document-querySelectorAll">document.querySelector和document.querySelectorAll</h4><p>这两个api很相似，通过css选择器来查找元素，注意选择器要符合<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors" target="_blank" rel="external">CSS选择器</a>的规则。<br>首先来介绍一下document.querySelector。<br>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。我们来看这个<a href="http://runjs.cn/detail/dl1uvbtq" target="_blank" rel="external">例子</a>：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;span <span class="type">class</span>=<span class="string">"test"</span>&gt;第三级的span&lt;/span&gt;	</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;			</span><br><span class="line">    同级的第二个<span class="keyword">div</span></span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> <span class="property">id</span>=<span class="string">"btnGet"</span> value=<span class="string">"获取test元素"</span> /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">"btnGet"</span>).addEventListener(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">	var element = document.querySelector(<span class="string">".test"</span>);</span><br><span class="line">	alert(element.textContent);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这个例子很简单，就是两个class都包含“test”的元素，一个在文档树的前面，但是它在第三级，另一个在文档树的后面，但它在第一级，通过querySelector获取元素时，它通过深度优先搜索，拿到文档树前面的第三级的元素。</p>
<p>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，我们来看看下面这个<a href="http://runjs.cn/detail/egu0tjoj" target="_blank" rel="external">例子</a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"test"</span>&gt;</span><br><span class="line">    <span class="type">class</span>为test</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"test"</span>&gt;</span><br><span class="line">    <span class="property">id</span>为test</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;input <span class="property">id</span>=<span class="string">"btnShow"</span> type=<span class="string">"button"</span> value=<span class="string">"显示内容"</span> /&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">"btnShow"</span>).addEventListener(<span class="string">"click"</span>,function()&#123;</span><br><span class="line">	var elements = document.querySelectorAll(<span class="string">"#test,.test"</span>);	</span><br><span class="line">	<span class="keyword">for</span>(var i = <span class="number">0</span>,<span class="property">length</span> = elements.<span class="property">length</span>;i&lt;<span class="property">length</span>;i++)&#123;</span><br><span class="line">		alert(elements[i].textContent);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这段代码通过querySelectorAll，使用id选择器和class选择器选择了两个元素，并依次输出其内容。要注意两点：<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化</p>
<p>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。</p>
<h3 id="节点关系型api">节点关系型api</h3><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。</p>
<h4 id="父关系型api">父关系型api</h4><p>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p>
<h4 id="兄弟关系型api">兄弟关系型api</h4><p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<p>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<h4 id="子关系型api">子关系型api</h4><p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。</p>
<h3 id="元素属性型api">元素属性型api</h3><h4 id="setAttribute">setAttribute</h4><p>setAttribute：根据名称和值修改元素的特性，用法如下。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.setAttribute(<span class="keyword">name</span>, <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。<br>如果元素本身包含指定的特性名为属性，则可以世界访问属性进行赋值，比如下面两条代码是等价的：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">element</span>.setAttribute(<span class="string">"id"</span>,<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line"><span class="literal">element</span>.id = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="getAttribute">getAttribute</h4><p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串。用法如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = element.getAttribute(<span class="string">"id"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="元素样式型api">元素样式型api</h3><h4 id="window-getComputedStyle">window.getComputedStyle</h4><p>window.getComputedStyle是用来获取应用到元素后的样式，假设某个元素并未设置高度而是通过其内容将其高度撑开，这时候要获取它的高度就要用到getComputedStyle，用法如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> style = <span class="built_in">window</span>.getComputedStyle(element[, pseudoElt]);</span><br></pre></td></tr></table></figure></p>
<p>element是要获取的元素，pseudoElt指定一个伪元素进行匹配。<br>返回的style是一个CSSStyleDeclaration对象。<br>通过style可以访问到元素计算后的样式</p>
<h4 id="getBoundingClientRect">getBoundingClientRect</h4><p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置，用法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> clientRect</span> = element.getBoundingClientRect();</span><br></pre></td></tr></table></figure></p>
<p>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等数据，具体可查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">链接</a></p>
<h3 id="总结">总结</h3><p>本文主要总结了原生js中常用的操作DOM的api接口，主要为了复习基础知识。平时开发用多了jQuery等类库，对基础知识的了解可能就渐渐地遗忘，但这些基础知识才是我们立足的根本，只有掌握原生的js，才能真正做好js的开发。</p>
]]></content>
    <summary type="html">
    <![CDATA[文本整理了javascript操作DOM的一些常用的api，根据其作用整理成为创建，修改，查询等多种类型的api，主要用于复习基础知识，加深对原生js的认识。]]>
    
    </summary>
    
      <category term="dom" scheme="http://luopq.com/tags/dom/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：状态模式]]></title>
    <link href="http://luopq.com/2015/11/25/design-pattern-state/"/>
    <id>http://luopq.com/2015/11/25/design-pattern-state/</id>
    <published>2015-11-25T06:59:34.000Z</published>
    <updated>2015-11-30T15:46:27.632Z</updated>
    <content type="html"><![CDATA[<p>在软件开发中，很大部分时候就是操作数据，而不同数据下展示的结果我们将其抽象出来称为状态，我们平时开发时本质上就是对应用程序的各种状态进行切换并作出相应处理。状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以可以让代码更加清晰，提高应用程序的维护性和扩展性。</p>
<h3 id="基础知识">基础知识</h3><p>状态模式定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成：<br>（1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。<br>（2）状态类：表示一种状态，包含其相应的处理方法</p>
<h3 id="状态模式的实现">状态模式的实现</h3><h4 id="基本示例">基本示例</h4><p>我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。<br>首先，需要一个最基本的红绿灯对象，我们定义如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trafficLight = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> currentLight = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         change: <span class="function"><span class="keyword">function</span> <span class="params">(light)</span> </span>&#123;</span><br><span class="line">             currentLight = light;</span><br><span class="line">             currentLight.go();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。<br>接着我们定义三种不同颜色的灯，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RedLight</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">RedLight.prototype.go = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is red light"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GreenLight</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">GreenLight.prototype.go = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is green light"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">YellowLight</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">YellowLight.prototype.go = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this is yellow light"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。<br>接着，我们在客户端进行切换不同颜色的灯：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trafficLight.<span class="keyword">change</span>(<span class="keyword">new</span> RedLight());</span><br><span class="line">trafficLight.<span class="keyword">change</span>(<span class="keyword">new</span> YellowLight());</span><br></pre></td></tr></table></figure></p>
<p>通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，这就是一个典型的状态模式的应用。</p>
<h4 id="JS组件开发中的状态模式">JS组件开发中的状态模式</h4><p>状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发<br>比如我们要开发一个菜单组件，菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。使用状态模式的话，我们首先定义一个环境类，在这里也就是菜单对象，简单地定义如下：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Menu() &#123; &#125;</span><br><span class="line">Menu.prototype.toggle = function (<span class="keyword">state</span>) &#123;</span><br><span class="line">    <span class="keyword">state</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。<br>接着我们定义两种状态，定义如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> menuStates = &#123;</span><br><span class="line">    <span class="string">"show"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the menu is showing"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"hide"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"the menu is hiding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里，通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。在使用的时候通过下面的方法进行调用：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">menu</span> = new Menu();</span><br><span class="line"><span class="keyword">menu</span>.<span class="keyword">toggle</span>(menuStates.show);</span><br><span class="line"><span class="keyword">menu</span>.<span class="keyword">toggle</span>(menuStates.<span class="keyword">hide</span>);</span><br></pre></td></tr></table></figure></p>
<p>这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，我们只需要menuStates添加相应的状态和处理程序即可。</p>
<h3 id="总结">总结</h3><p>状态模式在开发Web组件时非常有用，能让我们的代码结构更加清晰，能够很方便的增加组件的各种状态。使用状态模式的关键是要理清组件的各种状态，搞清楚组件的不同状态和相应的处理函数，对组件后期的维护和扩展有极大的好处。</p>
]]></content>
    <summary type="html">
    <![CDATA[在软件开发中，很大部分时候就是操作数据，而不同数据下展示的结果我们将其抽象出来称为状态，我们平时开发时本质上就是对应用程序的各种状态进行切换并作出相应处理。状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以可以让代码更加清晰，提高应用程序的维护性和扩展性。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：观察者模式]]></title>
    <link href="http://luopq.com/2015/11/24/design-pattern-observer/"/>
    <id>http://luopq.com/2015/11/24/design-pattern-observer/</id>
    <published>2015-11-24T15:28:07.000Z</published>
    <updated>2015-11-24T15:30:40.350Z</updated>
    <content type="html"><![CDATA[<p>观察者模式主要应用于对象之间一对多的依赖关系，当一个对象发生改变时，多个对该对象有依赖的其他对象也会跟着做出相应改变，这就非常适合用观察者模式来实现。使用观察者模式可以根据需要增加或删除对象，解决一对多对象间的耦合关系，使程序更易于扩展和维护。</p>
<h3 id="基础知识">基础知识</h3><p>观察者模式定义了对象间的一种一对多依赖关系，每当一个对象发生改变时，其相关依赖对象皆得到通知并被进行相应的改变。观察者模式又叫做发布-订阅模式。生活中有很多类似的关系，比如微信公众号订阅，多个读者订阅一个微信公众号，一旦公众号有更新，多个读者都会收到更新，而这种情况在应用程序中也非常常见，js绑定各种事件本质上就是观察者模式的实现。<br>观察者模式是一个非常有用的设计模式，它主要有两个角色组成：<br>（1）目标对象：作为一对多关系中的一，可以用来管理观察者的增加和删除<br>（2）观察者对象：观察目标对象，一旦目标发生改变则做出相应的反应</p>
<h3 id="观察者模式的实现">观察者模式的实现</h3><h4 id="基本示例">基本示例</h4><p>在Web开发中，我们经常遇到这种情况，ajax请求数据后，要同时更新数据到页面的不同部分中，这种情况我们可以最直接的在ajax的回调中更新页面，但是如果要更新的位置很多，我们就要去修改回调函数，这样代码的维护性和扩张性不高，这种情况下，我们就可以用观察者模式来实现。<br>首先，需要一个最基本的目标对象，我们定义如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">    constructor: Subject,</span><br><span class="line">    subscribe: <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.push(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribe: <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (item !== fn) &#123;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: <span class="function"><span class="keyword">function</span> <span class="params">(data, context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item)</span> </span>&#123;</span><br><span class="line">            item.call(context, data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>目标对象Subject中有一个数组，这个数组保存观察者列表，而目标对象提供三个方法：观察对象，取消观察对象，触发对象更新。<br>我们通过subscribe方法增加观察者，保存到observers数组中，如果有需要可以通过unsubscribe方法取消订阅，然后更新数据时调用fire方法触发，从而通知各个观察者进行相应处理。<br>假设我们页面有一个主视图和一个侧视图，两个视图都要进行相应的修改，我们可以定义两个对象如下：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SideView</span><span class="params">()</span> &#123;</span> &#125;</span><br><span class="line">SideView.prototype.<span class="built_in">render</span> = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"Side data:"</span> + data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainView</span><span class="params">()</span> &#123;</span> &#125;</span><br><span class="line">MainView.prototype.<span class="built_in">render</span> = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">"MainView data:"</span> + data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了两个对象，分别为侧视图和主视图，两个对象都有相应的渲染页面的方法render，然后我们将两个方法添加到观察者列表中。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> sideView = <span class="keyword">new</span> SideView();</span><br><span class="line"><span class="keyword">var</span> mainView = <span class="keyword">new</span> MainView();</span><br><span class="line"></span><br><span class="line">subject.subscribe(sideView.render)</span><br><span class="line">subject.subscribe(mainView.render);</span><br><span class="line">subject.fire(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过调用fire方法，传入“test”，从而触发两个render函数。从这段代码中，我们可以很轻松地通过subscribe来添加观察者对象，而不必每次都去修改fire方法。</p>
<h4 id="jQuery中的观察者模式">jQuery中的观察者模式</h4><p>jQuery中实现观察者模式非常方便，简短的几句代码就可以实现<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span> <span class="list">($)</span> <span class="collection">&#123;</span><br><span class="line">            var obj = $<span class="list">(<span class="collection">&#123;&#125;</span>)</span><span class="comment">;</span></span><br><span class="line">            $.subscribe = function <span class="list">()</span> <span class="collection">&#123;</span><br><span class="line">                obj.on.apply<span class="list">(<span class="keyword">obj</span>, arguments)</span><span class="comment">;</span></span><br><span class="line">            &#125;</span></span><br><span class="line">            $.unsubscribe = function <span class="list">()</span> <span class="collection">&#123;</span><br><span class="line">                obj.off.apply<span class="list">(<span class="keyword">obj</span>, arguments)</span><span class="comment">;</span></span><br><span class="line">            &#125;</span></span><br><span class="line">            $.fire = function <span class="list">()</span> <span class="collection">&#123;</span><br><span class="line">                obj.trigger.apply<span class="list">(<span class="keyword">obj</span>, arguments)</span><span class="comment">;</span></span><br><span class="line">            &#125;</span></span><br><span class="line">        &#125;</span>)</span><span class="list">(<span class="keyword">jQuery</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>在jQuery中，通过on方法来绑定事件，off来移除事件，trigger来触发事件，本质上就是一种观察者模式。上面代码中，我们通过一个obj对象来保存观察者对象，我们只要像平时绑定事件一样使用就可以，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.subscribe(<span class="string">"render"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$.subscribe(<span class="string">"render"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"test2"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$.fire(<span class="string">"render"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这段代码分别输出test和test2.我们绑定了两个处理函数到render上，然后通过fire触发render事件，这就实现了观察者模式一对多依赖的特点。</p>
<h3 id="总结">总结</h3><p>观察者模式是一种很常用的设计模式，因为我们的应用程序中涉及到依赖关系的非常多。常见的比如消息通知，向用户发送一个消息需要同时通知到站内信，邮件，短信等多种消息，这种一对多的情况非常适合使用观察者模式来实现。使用观察者模式的关键是在于理清目标对象和观察者对象，目标对象通过一个数组对观察者对象进行管理，更新数据的时候再循环调用观察者对象，从而实现观察者模式。</p>
]]></content>
    <summary type="html">
    <![CDATA[观察者模式主要应用于对象之间一对多的依赖关系，当一个对象发生改变时，多个对该对象有依赖的其他对象也会跟着做出相应改变，这就非常适合用观察者模式来实现。使用观察者模式可以根据需要增加或删除对象，解决一对多对象间的耦合关系，使程序更易于扩展和维护。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：享元模式]]></title>
    <link href="http://luopq.com/2015/11/20/design-pattern-flyweight/"/>
    <id>http://luopq.com/2015/11/20/design-pattern-flyweight/</id>
    <published>2015-11-20T03:47:03.000Z</published>
    <updated>2015-11-24T15:29:18.997Z</updated>
    <content type="html"><![CDATA[<p>享元模式不同于一般的设计模式，它主要用来优化程序的性能，它最适合解决大量类似的对象而产生的性能问题。享元模式通过分析应用程序的对象，将其解析为内在数据和外在数据，减少对象的数量，从而提高应用程序的性能。</p>
<h3 id="基本知识">基本知识</h3><p>享元模式通过共享大量的细粒度的对象，减少对象的数量，从而减少对象的内存，提高应用程序的性能。其基本思想就是分解现有类似对象的组成，将其展开为可以共享的内在数据和不可共享的外在数据，我们称内在数据的对象为享元对象。通常还需要一个工厂类来维护内在数据。<br>在JS中，享元模式主要有下面几个角色组成：<br>（1）客户端：用来调用享元工厂来获取内在数据的类，通常是应用程序所需的对象，<br>（2）享元工厂：用来维护享元数据的类<br>（3）享元类：保持内在数据的类</p>
<h3 id="享元模式的实现和应用">享元模式的实现和应用</h3><h4 id="一般实现">一般实现</h4><p>我们举个例子进行说明：苹果公司批量生产iphone，iphone的大部分数据比如型号，屏幕都是一样，少数部分数据比如内存有分16G,32G等。未使用享元模式前，我们写代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">Iphone</span><span class="params">(model, screen, memory, SN)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>. model  = model;</span><br><span class="line">    <span class="keyword">this</span>.screen = screen;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    <span class="keyword">this</span>.SN = SN;</span><br><span class="line">&#125;</span><br><span class="line">var phones = [];</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    var memory = i % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">16</span> : <span class="number">32</span>;</span><br><span class="line">    phones.push(<span class="keyword">new</span> Iphone(<span class="string">"iphone6s"</span>, <span class="number">5.0</span>, memory, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中，创建了一百万个iphone，每个iphone都独立申请一个内存。但是我们仔细观察可以看到，大部分iphone都是类似的，只是内存和序列号不一样，如果是一个对性能要求比较高的程序，我们就要考虑去优化它。<br>大量相似对象的程序，我们就可以考虑用享元模式去优化它，我们分析出大部分的iphone的型号，屏幕，内存都是一样的，那这部分数据就可以公用，就是享元模式中的内在数据，定义享元类如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IphoneFlyweight</span><span class="params">(model, screen, memory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model;</span><br><span class="line">    <span class="keyword">this</span>.screen = screen;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了iphone的享元类，其中包含型号，屏幕和内存三个数据。我们还需要一个享元工厂来维护这些数据：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> flyweightFactory = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iphones = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">(model, screen, memory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> key = model + screen + memory;</span><br><span class="line">            <span class="keyword">if</span> (!iphones[key]) &#123;</span><br><span class="line">                iphones[key] = <span class="keyword">new</span> IphoneFlyweight(model, screen, memory);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> iphones[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>在这个工厂中，我们定义了一个字典来保存享元对象，提供一个方法根据参数来获取享元对象，如果字典中有则直接返回，没有则创建一个返回。<br>接着我们创建一个客户端类，这个客户端类就是修改自iphone类：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Iphone</span><span class="params">(model, screen, memory, SN)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flyweight = flyweightFactory.<span class="keyword">get</span>(model, screen, memory);</span><br><span class="line">    <span class="keyword">this</span>.SN = SN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们依旧像之间那样生成多个iphone<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var phones = [];</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    var memory = i % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">16</span> : <span class="number">32</span>;</span><br><span class="line">    phones.push(<span class="keyword">new</span> Iphone(<span class="string">"iphone6s"</span>, <span class="number">5.0</span>, memory, i));</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(phones);</span><br></pre></td></tr></table></figure></p>
<p>这里的关键就在于Iphone构造函数里面的this.flyweight = flyweightFactory.get(model, screen, memory)。这句代码通过享元工厂去获取享元数据，而在享元工厂里面，如果已经存在相同数据的对象则会直接返回对象，多个iphone对象共享这部分相同的数据，所以原本类似的数据已经大大减少，减少的内存的占用。</p>
<h4 id="享元模式在DOM中的应用">享元模式在DOM中的应用</h4><p>享元模式的一个典型应用就是DOM事件操作，DOM事件机制分成事件冒泡和事件捕获。我们简单介绍一下这两者：<br>事件冒泡：绑定的事件从最里层的元素开始触发，然后冒泡到最外层<br>事件捕获：绑定的事件从最外层的元素开始触发，然后传到最里层<br>假设我们HTML中有一个菜单列表<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">"menu"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项1&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项2&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项3&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项4&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项5&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">li</span> <span class="keyword">class</span>=<span class="string">"item"</span>&gt;选项6&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>点击菜单项，进行相应的操作，我们通过jQuery来绑定事件，一般会这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".item"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="keyword">this</span>).text());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>给每个列表项绑定事件，点击输出相应的文本。这样看暂时没有什么问题，但是如果是一个很长的列表，尤其是在移动端特别长的列表时，就会有性能问题，因为每个项都绑定了事件，都占用了内存。但是这些事件处理程序其实都是很类似的，我们就要对其优化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".menu"</span>).on(<span class="string">"click"</span>, <span class="string">".item"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log($(<span class="keyword">this</span>).text());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>通过这种方式进行事件绑定，可以减少事件处理程序的数量，这种方式叫做事件委托，也是运用了享元模式的原理。事件处理程序是公用的内在部分，每个菜单项各自的文本就是外在部分。我们简单说下事件委托的原理：点击菜单项，事件会从li元素冒泡到ul元素，我们绑定事件到ul上，实际上就绑定了一个事件，然后通过事件参数event里面的target来判断点击的具体是哪一个元素，比如低级第一个li元素，event.target就是li，这样就能拿到具体的点击元素了，就可以根据不同元素进行不同的处理。</p>
<h3 id="总结">总结</h3><p>享元模式是一种优化程序性能的手段，通过共享公用数据来减少对象数量以达到优化程序的手段。享元模式适用于拥有大量类似对象并且对性能有要求的场景。因为享元模式需要分离内部和外部数据，增加了程序的逻辑复杂性，建议对性能有要求的时候才使用享元模式。</p>
]]></content>
    <summary type="html">
    <![CDATA[享元模式不同于一般的设计模式，它主要用来优化程序的性能，它最适合解决大量类似的对象而产生的性能问题。享元模式通过分析应用程序的对象，将其解析为内在数据和外在数据，减少对象的数量，从而提高应用程序的性能。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：组合模式]]></title>
    <link href="http://luopq.com/2015/11/16/design-pattern-composite/"/>
    <id>http://luopq.com/2015/11/16/design-pattern-composite/</id>
    <published>2015-11-16T04:41:39.000Z</published>
    <updated>2015-11-24T15:29:18.996Z</updated>
    <content type="html"><![CDATA[<p>我们平时开发过程中，一定会遇到这种情况：同时处理简单对象和由简单对象组成的复杂对象，这些简单对象和复杂对象会组合成树形结构，在客户端对其处理的时候要保持一致性。比如电商网站中的产品订单，每一张产品订单可能有多个子订单组合，比如操作系统的文件夹，每个文件夹有多个子文件夹或文件，我们作为用户对其进行复制，删除等操作时，不管是文件夹还是文件，对我们操作者来说是一样的。在这种场景下，就非常适合使用组合模式来实现。</p>
<h3 id="基本知识">基本知识</h3><p>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>组合模式主要有三个角色：<br>（1）抽象组件（Component）：抽象类，主要定义了参与组合的对象的公共接口<br>（2）子对象（Leaf）：组成组合对象的最基本对象<br>（3）组合对象（Composite）：由子对象组合起来的复杂对象<br>理解组合模式的关键是要理解组合模式对单个对象和组合对象使用的一致性，我们接下来说说组合模式的实现加深理解。</p>
<h3 id="组合模式的实现">组合模式的实现</h3><h4 id="最简单的组合模式">最简单的组合模式</h4><p>HTML文档的DOM结构就是天生的树形结构，最基本的元素醉成DOM树，最终形成DOM文档，非常适用适用组合模式。<br>我们常用的jQuery类库，其中组合模式的应用更是频繁，例如经常有下列代码实现：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".test"</span>).addClass(<span class="string">"noTest"</span>).<span class="keyword">remove</span>(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这句简单的代码就是获取class包含test的元素，然后进行addClass和removeClass处理，其中不论$(“.test”)是一个元素，还是多个元素，最终都是通过统一的addClass和removeClass接口进行调用。<br>我们简单模拟一下addClass的实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addClass = <span class="function"><span class="keyword">function</span> (<span class="params">eles, className</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eles <span class="keyword">instanceof</span> NodeList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = eles.length; i &lt; length; i++) &#123;</span><br><span class="line">            eles[i].nodeType === <span class="number">1</span> &amp;&amp; (eles[i].className += (<span class="string">' '</span> + className + <span class="string">' '</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eles <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">        eles.nodeType === <span class="number">1</span> &amp;&amp; (eles.className += (<span class="string">' '</span> + className + <span class="string">' '</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"eles is not a html node"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addClass(<span class="built_in">document</span>.getElementById(<span class="string">"div3"</span>), <span class="string">"test"</span>);</span><br><span class="line">addClass(<span class="built_in">document</span>.querySelectorAll(<span class="string">".div"</span>), <span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这段代码简单的模拟了addClass的实现（暂不考虑兼容性和通用性），很简单地先判断节点类型，然后根据不同类型添加className。对于NodeList或者是Node来说，客户端调用都是同样的使用了addClass这个接口，这个就是组合模式的最基本的思想，使部分和整体的使用具有一致性。</p>
<h4 id="典型的例子">典型的例子</h4><p>前面我们提到一个典型的例子：产品订单包含多个产品子订单，多个产品子订单组成一个复杂的产品订单。由于Javascript语言的特性，我们将组合模式的三个角色简化成2个角色：<br>（1）子对象：在这个例子中，子对象就是产品子订单<br>（2）组合对象：这里就是产品的总订单<br>假设我们开发一个旅游产品网站，其中包含机票和酒店两种子产品，我们定义了子对象如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FlightOrder</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">FlightOrder.prototyp.create = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"flight order created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HotelOrder</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">HotelOrder.prototype.create = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hotel order created"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了两个类：机票订单类和酒店订单类，每个类都有各自的订单创建方法。<br>接下来我们创建一个总订单类：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TotalOrders</span><span class="params">()</span> &#123;</span></span><br><span class="line">    this.orderList = <span class="matrix">[]</span>;</span><br><span class="line">&#125;</span><br><span class="line">TotalOrders.prototype.addOrder = <span class="function"><span class="keyword">function</span> <span class="params">(order)</span> &#123;</span></span><br><span class="line">    this.orderList.push(order);</span><br><span class="line">&#125;</span><br><span class="line">TotalOrders.prototype.create = <span class="function"><span class="keyword">function</span> <span class="params">(order)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>, <span class="built_in">length</span> = this.orderList.<span class="built_in">length</span>; <span class="built_in">i</span> &lt; <span class="built_in">length</span>; <span class="built_in">i</span>++) <span class="cell">&#123;</span><br><span class="line">        this.orderList[i].create();</span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个对象主要有3个成员：订单列表，添加订单的方法，创建订单的方法。<br>在客户端使用的时候如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flight = <span class="keyword">new</span> FlightOrder();</span><br><span class="line">flight.<span class="keyword">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orders = <span class="keyword">new</span> TotalOrders();</span><br><span class="line">orders.addOrder(<span class="keyword">new</span> FlightOrder());</span><br><span class="line">orders.addOrder(<span class="keyword">new</span> HotelOrder());</span><br><span class="line">orders.<span class="keyword">create</span>();</span><br></pre></td></tr></table></figure></p>
<p>客户端调用展示了两种方式，一种是单一的创建机票订单，一种是创建多张订单，但最终都是通过create方法进行创建，这就是一个很典型的组合模式的应用场景。</p>
<h3 id="总结">总结</h3><p>组合模式并不难理解，它主要解决的是单一对象和组合对象在使用方式上的一致性问题。如果对象具有明显的层次结构并且想要统一地使用它们，这就非常适合使用组合模式。在Web开发中，这种层次结构非常常见，很适合使用组合模式，尤其是对于JS来说，不用拘泥于传统面向对象语言的形式，灵活地利用JS语言的特性，达到对部分和整体使用的一致性。</p>
]]></content>
    <summary type="html">
    <![CDATA[我们平时开发过程中，一定会遇到这种情况：同时处理简单对象和由简单对象组成的复杂对象，这些简单对象和复杂对象会组合成树形结构，在客户端对其处理的时候要保持一致性。比如电商网站中的产品订单，每一张产品订单可能有多个子订单组合，比如操作系统的文件夹，每个文件夹有多个子文件夹或文件，我们作为用户对其进行复制，删除等操作时，不管是文件夹还是文件，对我们操作者来说是一样的。在这种场景下，就非常适合使用组合模式来实现。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CSS position属性]]></title>
    <link href="http://luopq.com/2015/11/15/css-position/"/>
    <id>http://luopq.com/2015/11/15/css-position/</id>
    <published>2015-11-15T02:05:16.000Z</published>
    <updated>2015-11-15T02:24:53.949Z</updated>
    <content type="html"><![CDATA[<p>position是CSS中非常重要的一个属性，通过position属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。postion也是初学者容易搞不清楚状况的一个属性，本文将从最基础的知识讲起，谈谈关于positon属性的一些理论与应用。</p>
<h3 id="基础知识">基础知识</h3><p>postion属性我们成为定位，它有4个不同类型的定位，这些类型会影响元素的生成方式，下面我们详细说明position属性。</p>
<h4 id="position四种类型">position四种类型</h4><p>（1）static<br>static是position属性的默认值，默认情况下，块级元素和行内元素按照各自的特性进行显示<br>（2）relative<br>relative翻译成中文称相对定位，设置了这个属性后，元素会根据top，left，bottom，right进行偏移，关键点是它原本的空间仍然保留。我们看下面例子：<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"relative"</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo1.jpg" alt="relative效果" title="relative效果"></p>
<p>在这个例子中，div.relative相对定位，并且left设置为20px，left设置为50px，其相对于父元素进行偏移，并且原本的空间也占据着，下面的元素并不会顶替上去。</p>
<p>（3）absolute<br>元素设置成absolute后会脱离文档流，并且不占有原本的空间，后面的元素会顶替上去，而且不论元素是行内元素还是块级元素，都会生成一个块级框，也就是例如行内元素span设置了absolute后就可以设置height和width属性了。看下面例子：<br>HTML代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"absolute"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.absolute</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo2.jpg" alt="absolute效果" title="absolute效果"></p>
<p>如图所示，span标签被设置成绝对定位，就可以设置height和width属性，而且不占有原本的空间，后面的div元素会顶替上去。</p>
<p>（4）fixed<br>fixed的表现方式类似于absolute，但是相比于absolute相对于不确定的父元素进行偏移，fixed就是相对于浏览器窗口进行偏移</p>
<h4 id="包含块">包含块</h4><p>在<a href="http://luopq.com/2015/11/08/CSS-float/">详解CSS float属性</a>中我们提到包含块这个概念。对于position属性也有包含块这个属性，它要分几种情况来讨论：<br>1.根元素的包含块，根元素一般是html元素，有些浏览器会使用body作为根元素，大多数浏览器，初始包含块是一个视窗大小的矩形<br>2.非根元素的包含块，如果该元素的position是relative或static，它的包含块是最近的块级框，表的单元格或行内块的内容边界<br>我们举例进行说明，<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">    我是父级元素的内容        </span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"relative"</span>&gt;</span><br><span class="line">        相对定位元素</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo3.jpg" alt="包含块" title="包含块"></p>
<p>这是相对定位元素的包含块，为最近的块级框，表的单元格或行内块的内容边界，相对定位元素相对于其包含块进行偏移，我们可以简单理解为相对于其原来的位置进行偏移。</p>
<p>3.非根元素的包含块，如果该元素的position是absolute，则包含块为最近的position不是static的祖先元素。<br>简单来说，它的包含块会从父级元素一直向上查找，找到第一个position不是static的元素为止。</p>
<h4 id="偏移属性">偏移属性</h4><p>前面的例子中已经涉及到偏移属性，它指的是元素相对于其包含块的偏移，我们称其为偏移属性，分别是top，bottom，left，right，依次代表上下左右。他们的值可以是具体的数值，也可以是百分比。如果是百分比，top和bottom是相对于包含块高度的百分比，left和right是相对于宽度的百分比。它们也可以设置负值，即有可能将元素移动到包含块的外边。</p>
<h3 id="绝对定位">绝对定位</h3><p>接下来我们了解一下绝对定位的详细细节。</p>
<h4 id="基本的绝对定位">基本的绝对定位</h4><p>一个元素被设置为绝对定位时，会脱离文档流，然后相对其包含块进行偏移。<br>一般来说，我们会将一个元素设置为relative来作为absolute元素的包含块，我们看看下面的例子：<br>HTML代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"absolute"</span>&gt;</span></span><br><span class="line">        相对于初始包含块定位</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"relative"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"absolute"</span>&gt;</span></span><br><span class="line">            相对于最近relative祖先元素定位</span><br><span class="line">        <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.absolute</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#988c8c</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo4.jpg" alt="基本的绝对定位" title="基本的绝对定位"><br>如图所示，有两个绝对定位元素，第一个元素没有position不是static的祖先元素，所以它的包含块是body，根据body进行偏移，<br>第二个绝对定位元素设置了一个relative的父元素，它根据父元素进行偏移。</p>
<h4 id="绝对定位的重叠问题">绝对定位的重叠问题</h4><p>元素设置成绝对定位后会脱离文档流，并且失去占用的空间，而且如果偏移的位置接近，会造成重叠问题。看看下面的例子：<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"relative"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"absolute"</span>&gt;</span><br><span class="line">        相对于最近relative祖先元素定位<span class="number">1</span></span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"absolute light"</span>&gt;</span><br><span class="line">        相对于最近relative祖先元素定位<span class="number">2</span></span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">300px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.absolute</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#988c8c</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.light</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#f3d6d6</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">70px</span></span></span>; <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">80px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo5.jpg" alt="绝对定位的重叠问题" title="绝对定位的重叠问题"></p>
<p>我们可以看到，第二个绝对定位元素盖住了第一个元素，那怎么让第一个元素盖住第二个元素呢，这就要用到z-index属性，这个属性表示元素的叠加顺序，默认情况下，z-index为0，数值越高的元素层级越高，就可以盖住低于其层级的元素，我们设置第一个原色的z-index为10，结果如下<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo6.jpg" alt="绝对定位的重叠问题" title="绝对定位的重叠问题"><br>如果两个元素的层级相同，则越后面的元素会覆盖前面的元素，默认情况下，第二个元素就会盖住第一个元素。</p>
<h3 id="固定定位">固定定位</h3><p>fixed定位很简单，类似与absoulte，但是它的包含块就是浏览器窗口，相对来说简单很多。常见的应用比如固定导航，回到顶部。在这里不再赘述，大家可以查找相关资料。</p>
<h3 id="相对定位">相对定位</h3><p>relative定位的元素进行偏移后，不会脱离文档流，还有占据原本的空间。除此之外，我们还要注意一个细节：如果元素设置了margin为负值之后发生重叠的情况下，相对定位的元素会覆盖普通元素。我们看看下面的例子：<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"no-relative"</span>&gt;</span><br><span class="line">    未相对定位的元素</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"minus-margin"</span>&gt;</span><br><span class="line">    负margin元素</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.no-relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.relative</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; &#125;</span></span><br><span class="line"><span class="class">.minus-margin</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> -<span class="number">30px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo7.jpg" alt="未相对定位时没有覆盖" title="未相对定位时没有覆盖"><br>默认情况下，两个元素都是正常的元素，设置了负的margin属性后，后面的元素会覆盖前面的元素，我们修改第一个元素的class为relative，可以看到效果如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo8.jpg" alt="相对定位时覆盖" title="相对定位时覆盖"><br>添加了相对定位后，第一个元素就会覆盖其他正常的元素了。</p>
<p>relative属性最经常的一个应用应该是作为absolute元素的包含块了，为了限制absolute元素的偏移位置，常常设置其父元素为relative来作为其包含块。</p>
<h3 id="应用举例">应用举例</h3><p>position的应用非常频繁，下面我来说说常见的一些场景：</p>
<h4 id="产品标签">产品标签</h4><p>在电商网站中，我们常常可以看到产品的左上角或右上角有一些比如“新品”，“促销”，“热卖”等标签，比如下图：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo9.jpg" alt="产品标签" title="产品标签"><br>这个是怎么实现的呢，我们来模拟一下：<br>HTML代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"product"</span>&gt;</span><br><span class="line">        我是产品</span><br><span class="line">        &lt;span <span class="type">class</span>=<span class="string">"hot"</span>&gt;</span><br><span class="line">            热卖</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.product</span> <span class="rules">&#123; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">150px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; &#125;</span></span><br><span class="line">   <span class="class">.hot</span> <span class="rules">&#123; <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo10.jpg" alt="产品标签" title="产品标签"><br>如图所示，右上角有一个标签。原理很简单，就是设置父元素相对定位，标签元素绝对定位，然后相对于父元素偏移到右上角。</p>
<h4 id="自动完成框">自动完成框</h4><p>自动完成框是一个非常常见的应用，其生成的下拉菜单也是用到了position属性。我们先看看下面的效果：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/css-position-demo11.jpg" alt="自动完成输入框" title="自动完成输入框"><br>这是一个很简单常见的下来自动完成框，我们来看看它的HTML和CSS代码：<br>HTML代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"search-box"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">placeholder</span>=<span class="value">"请输入关键字"</span> <span class="attribute">value</span>=<span class="value">"position"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">style</span>=<span class="value">"left:58px;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span>position属性<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span>position应用<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span>position是什么<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span>position翻译<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.search-box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">24px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50px</span></span></span>; &#125;</span></span><br><span class="line"><span class="tag">ul</span>, <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; &#125;</span></span><br><span class="line"><span class="tag">ul</span> <span class="rules">&#123; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">210px</span></span></span>; <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>; &#125;</span></span><br><span class="line"><span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个原理也很简单，通过设置下拉菜单为绝对定位，然后设置其left属性与输入框对齐。</p>
<p>当然position的应用还有很多，比如布局，比如fixed可以用来做固定导航菜单，网页右下角的固定菜单等，有兴趣的同学可以自行查找相关资料进行学习。</p>
<h3 id="总结">总结</h3><p>position属性是一个容易让初学者迷惑的属性，尤其是absolute和relative的应用。要用好它们，首先要从absolute和relative的基本特性开始了解，理解了他们的特性之后应用起来就得心应手了，了解基本原理后，多多写几个例子从实践中去体会它们的特性，慢慢的就会熟悉了。</p>
]]></content>
    <summary type="html">
    <![CDATA[position是CSS中非常重要的一个属性，通过position属性，我们可以让元素相对于其正常位置，父元素或者浏览器窗口进行偏移。postion也是初学者容易搞不清楚状况的一个属性，本文将从最基础的知识讲起，谈谈关于positon属性的一些理论与应用。]]>
    
    </summary>
    
      <category term="CSS" scheme="http://luopq.com/tags/CSS/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：桥接模式]]></title>
    <link href="http://luopq.com/2015/11/11/design-pattern-bridge/"/>
    <id>http://luopq.com/2015/11/11/design-pattern-bridge/</id>
    <published>2015-11-11T14:37:21.000Z</published>
    <updated>2015-11-11T14:40:29.217Z</updated>
    <content type="html"><![CDATA[<p>桥接模式将抽象部分与实现部分分离开来，使两者都可以独立的变化，并且可以一起和谐地工作。抽象部分和实现部分都可以独立的变化而不会互相影响，降低了代码的耦合性，提高了代码的扩展性。</p>
<h3 id="基本理论">基本理论</h3><p>桥接模式定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>桥接模式主要有4个角色组成：<br>（1）抽象类<br>（2）扩充抽象类<br>（3）实现类接口<br>（4）具体实现类<br>根据javascript语言的特点，我们将其简化成2个角色：<br>（1）扩充抽象类<br>（2）具体实现类<br>怎么去理解桥接模式呢？我们接下来举例说明</p>
<h3 id="桥接模式的实现">桥接模式的实现</h3><p>理解桥接模式的思想，关键是要理解其分离抽象部分和实现部分的思想。我们举例进行说明</p>
<h4 id="最简单的桥接模式">最简单的桥接模式</h4><p>其实我们最经常用的jQuery的each函数就是一个典型的桥接模式，我们模拟其实现如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">each</span> = <span class="function"><span class="keyword">function</span> <span class="params">(arr, fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> val = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (fn.call(val, i, val, arr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">each</span>(arr, <span class="function"><span class="keyword">function</span> <span class="params">(i, v)</span> </span>&#123;</span><br><span class="line">    arr[i] = v * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们通过each函数循环了arr数组，别看这个例子很常见，但其中就包含了典型的桥接模式。<br>在这个例子中，抽象部分是each函数，也就是上面说的扩充抽象类，实现部分是fn，即具体实现类。抽象部分和实现部分可以独立的进行变化。这个例子虽然简单，但就是一个典型的桥接模式的应用。</p>
<h4 id="插件开发中的桥接模式">插件开发中的桥接模式</h4><p>桥接模式的一个适用场景是组件开发。我们平时开发组件为了适应不同场合，组件相应的会有许多不同维度的变化。桥接模式就可以应用于此，将其抽象与实现分离，使组件的扩展性更高。<br>假设我们要开发一个弹窗插件，弹窗有不同的类型：普通消息提醒，错误提醒，每一种提醒的展示方式还都不一样。这是一个典型的多维度变化的场景。首先我们定义两个类：普通消息弹窗和错误消息弹窗。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MessageDialog</span><span class="params">(animation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animation = animation;</span><br><span class="line">&#125;</span><br><span class="line">MessageDialog.prototype.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animation.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorDialog</span><span class="params">(animation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animation = animation;</span><br><span class="line">&#125;</span><br><span class="line">ErrorDialog.prototype.show = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animation.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个类就是前面提到的抽象部分，也就是扩充抽象类，它们都包含一个成员animation。<br>两种弹窗通过show方法进行显示，但是显示的动画效果不同。我们定义两种显示的效果类如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinerAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">LinerAnimation.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"it is liner"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EaseAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">EaseAnimation.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"it is ease"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个类就是具体实现类，它们实现具体的显示效果。那我们如何调用呢？<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> MessageDialog(<span class="keyword">new</span> LinerAnimation());</span><br><span class="line">message.show();</span><br><span class="line"><span class="keyword">var</span> error = <span class="keyword">new</span> ErrorDialog(<span class="keyword">new</span> EaseAnimation());</span><br><span class="line">error.show();</span><br></pre></td></tr></table></figure></p>
<p>如果我们要增加一种动画效果，可以再定义一种效果类，传入即可。</p>
<h3 id="总结">总结</h3><p>学习桥接模式关键是要理解抽象部分与实现部分的分离，使得二者可以独立的变化，而不必拘泥于形式。JS插件灵活的变化，适用场景的多变就非常适合使用这种模式来实现。使用桥接模式最重要的是要找出系统中不同的变化维度。</p>
]]></content>
    <summary type="html">
    <![CDATA[桥接模式将抽象部分与实现部分分离开来，使两者都可以独立的变化，并且可以一起和谐地工作。抽象部分和实现部分都可以独立的变化而不会互相影响，降低了代码的耦合性，提高了代码的扩展性。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：适配器模式]]></title>
    <link href="http://luopq.com/2015/11/10/desgin-pattern-adapter/"/>
    <id>http://luopq.com/2015/11/10/desgin-pattern-adapter/</id>
    <published>2015-11-10T15:00:44.000Z</published>
    <updated>2015-11-10T15:01:59.123Z</updated>
    <content type="html"><![CDATA[<p>有的时候在开发过程中，我们会发现，客户端需要的接口和提供的接口发生不兼容的问题。由于特殊的原因我们无法修改客户端接口。在这种情况下，我们需要适配现有接口和不兼容的类，这就要提到适配器模式。通过适配器，我们可以在不用修改旧代码的情况下也能使用它们，这就是适配器的能力。</p>
<h3 id="基本理论">基本理论</h3><p>适配器模式：将一个接口转换成客户端需要的接口而不需要去修改客户端代码，使得不兼容的代码可以一起工作。</p>
<p>适配器主要有3个角色组成：<br>（1）客户端：调用接口的类<br>（2）适配器：用来连接客户端接口和提供服务的接口的类<br>（3）适配者：提供服务，但是却与客户端接口需求不兼容服务类。</p>
<h3 id="适配器模式的实现">适配器模式的实现</h3><h4 id="最简单的适配器">最简单的适配器</h4><p>适配器模式没有想象中的那么复杂，举个最简单的例子。<br>客户端调用一个方法进行加法计算：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = add(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是我们没有提供add这个方法，提供了同样类似功能的sum方法：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(v1,v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免修改客户端和服务端，我们增加一个包装函数：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">function</span> <span class="keyword">add </span>(<span class="literal">v1</span>,<span class="literal">v2</span>)&#123;</span><br><span class="line">    reutrn sum(<span class="literal">v1</span>,<span class="literal">v2</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个最简单的适配器模式，我们在两个不兼容的接口之间添加一个包装方法，用这个方法来连接二者使其共同工作。</p>
<h4 id="实际应用">实际应用</h4><p>随着前端框架的发展，越来越多的开发者开始使用MVVM框架进行开发，只需要操作数据而不需要操作DOM元素，jQuery的作用越来越少。而很多项目中还是引用着jQuery库作用工具类，因为我们要利用jQuery提供的ajax去服务器请求数据。如果jQuery在项目中的作用仅仅是作为ajax工具库的话，有点杀鸡焉用牛刀的感觉，造成资源浪费。这个时候我们完全可以封装一个自己的ajax库。<br>假设我们封装的ajax就通过一个函数进行使用：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(&#123;</span><br><span class="line">    url:<span class="string">'/getData'</span>,</span><br><span class="line">    <span class="built_in">type</span>:<span class="string">'Post'</span>,</span><br><span class="line">    dataType:<span class="string">'json'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        id:<span class="string">"123"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>除了调用接口ajax与jQuery的$.ajax的不同，其他完全一样。<br>项目中请求ajax的地方必然很多，我们替换jQuery的时候不可能一个一个去修改$.ajax，那怎么办呢，这个时候，我们就可以增加一个适配器：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = &#123;</span><br><span class="line">    ajax:<span class="function"><span class="keyword">function</span> <span class="params">(options)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ajax(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就能兼容旧代码和新接口，避免对已有的代码的修改。</p>
<h3 id="总结">总结</h3><p>适配器模式的原理很简单，就是新增一个包装类，对新的接口进行包装以适应旧代码的调用，避免修改接口和调用代码。</p>
<p>适用场景：存在较多代码调用旧接口，为了避免修改旧代码和更换新接口，不影响现有实现方式的应用场景。</p>
]]></content>
    <summary type="html">
    <![CDATA[有的时候在开发过程中，我们会发现，客户端需要的接口和提供的接口发生不兼容的问题。由于特殊的原因我们无法修改客户端接口。在这种情况下，我们需要适配现有接口和不兼容的类，这就要提到适配器模式。通过适配器，我们可以在不用修改旧代码的情况下也能使用它们，这就是适配器的能力。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：工厂方法模式]]></title>
    <link href="http://luopq.com/2015/11/10/design-pattern-factory-method/"/>
    <id>http://luopq.com/2015/11/10/design-pattern-factory-method/</id>
    <published>2015-11-10T06:44:26.000Z</published>
    <updated>2015-11-11T11:11:28.232Z</updated>
    <content type="html"><![CDATA[<p>本文从简单工厂模式的缺点说起，引入工厂方法模式，介绍的工厂方法模式的基本知识，实现要点和应用场景，最后举例进行说明工厂方法模式的应用。<br>在之前的《<a href="http://luopq.com/2015/11/03/design-pattern-factory/">Javascript设计模式理论与实战：简单工厂模式</a>》这篇文章中，我们介绍了简单工厂的知识和一些应用。简单工厂模式存在一个唯一的工厂类，它的优点是所有产品类的实例化集中管理，便于理解，但这既是优点也是缺点。如果产品类的数量较少并且不会经常发生变化，我们可以直接利用简单工厂模式，但是有的时候，需求是随时在变的，产品类也可能随时在增加，如果使用简单工厂模式，就不可避免的要去修改工厂类的代码。要解决这个问题，就要提到今天要说的工厂方法模式。</p>
<h3 id="基本概念">基本概念</h3><p>工厂方法模式：不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的子工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不需要修改其他的工厂代码。</p>
<p>工厂方法模式主要有三种类组成：<br>1.抽象工厂类：负责定义创建产品的公共接口。<br>2.产品子工厂：继承抽象工厂类，实现抽象工厂类提供的接口<br>3.每一种产品各自的产品类</p>
<h3 id="工厂方法模式的实现">工厂方法模式的实现</h3><p>首先，我们对《<a href="http://luopq.com/2015/11/03/design-pattern-factory/">Javascript设计模式理论与实战：简单工厂模式</a>》一文中简单工厂模式的代码进行改造。下面是简单工厂公式的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productEnums = &#123;</span><br><span class="line">    flight: <span class="string">"flight"</span>,</span><br><span class="line">    hotel: <span class="string">"hotel"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Flight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is Flight"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hotel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is Hotel"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> productFactory = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> productFactories = &#123;</span><br><span class="line">        <span class="string">"flight"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Flight();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"hotel"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Hotel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createProduct: <span class="function"><span class="keyword">function</span> (<span class="params">productType</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> productFactories[productType]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.shopCart = [];</span><br><span class="line">&#125;</span><br><span class="line">User.prototype = &#123;</span><br><span class="line">    constructor: User,</span><br><span class="line">    order: <span class="function"><span class="keyword">function</span> (<span class="params">productType</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shopCart.push(productFactory.createProduct(productType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要将上面的代码修改成工厂方法模式，首先要构造一个抽象工厂类。在JS中，由于我们抽象类的概念，我们无法做到像Java，C#的抽象工厂类，但是我们可以去模拟它。代码如下<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">AbstractFactory.prototype.createProduct = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"没有实现该方法"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，定义了一个工厂类，然后定义了它的一个方法CreateProduct，这个方法模拟抽象方法，不提供具体实现，而是抛出错误，继承的工厂类就要去实现具体方法，否则会抛错，这就模拟了一个抽象工厂类。<br>定义完抽象工厂类后，现在我们要做的就是定义子工厂去实现它，我们分别定义两个子工厂FlightFactory和HotelFactory。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FlightFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">FlightFactory.prototype = <span class="keyword">new</span> AbstractFactory();</span><br><span class="line">FlightFactory.prototype.createProduct = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Flight();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HotelFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractFactory.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">HotelFactory.prototype = <span class="keyword">new</span> AbstractFactory();</span><br><span class="line">HotelFactory.prototype.createProduct = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Hotel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码分别定义了两个子工厂类，每个子类继承抽象工厂类，然后实现createProduct方法，每一种产品在各自的工厂类里创建。<br>在客户端怎么调用呢？<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">factory</span> = <span class="keyword">new</span> FlightFactory();</span><br><span class="line"><span class="literal">factory</span>.createProduct();</span><br><span class="line"><span class="literal">factory</span> = <span class="keyword">new</span> HotelFactory();</span><br><span class="line"><span class="literal">factory</span>.createProduct();</span><br></pre></td></tr></table></figure></p>
<h3 id="疑点解答">疑点解答</h3><p>首先我们要理解一个概念：开放封闭原则。<br>软件实体应该是可扩展但不可修改的，就是对扩展是开放但是对修改是封闭的。体现在两个方面：<br>（1）对扩展开放，产品有新需求或变活时，可以对现有代码进行扩展，以适应新变化<br>（2）对修改封闭，类一旦设计完成，就不应该对其进行修改。</p>
<p>下面来说说几个疑点<br>1、相比于简单工厂模式，工厂方法模式增多了一个抽象工厂类和多个子工厂类，这样代码不是更复杂了吗？<br>确实，代码比简单工厂模式复杂了，引入了抽象层，还有子工厂，这会增加代码的复杂度和理解难度。但是相比于简单工厂模式，代码的维护性和扩展性提高了，新增产品时，只需要增加对应的产品类和产品工厂类，不需要修改到抽象工厂类和其他子工厂。更加符合面向对象的开放封闭原则。<br>当然具体场景具体分析，复杂性和扩展性相比如何舍去，在使用的时候要结合实际场景去分析。<br>2、在客户端调用的时候，每一种产品还是需要知道具体的工厂类来调用，好像区别不大？<br>和简单工厂模式的区别在于：我们将判断使用哪一个产品类的代码从工厂类转移到了调用的客户端这里，如果有新功能要添加，我们要修改的是客户端的代码而不是工厂类的代码，这样才符合开放封闭原则。</p>
<h3 id="总结">总结</h3><h4 id="实现要点">实现要点</h4><p>在JS中，我们实现工厂方法模式主要包括3个角色：<br>1.抽象工厂类：提供工厂方法的声明<br>2.子工厂类：实现抽象工厂类的工厂方法<br>3.产品类：具体的产品类</p>
<h4 id="优缺点">优缺点</h4><p>优点：克服了简单工厂模式的缺点。如果需要增加新的产品类，无须修改现有系统，只需要增加新的工厂类和产品类；每个工厂类封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性。<br>缺点：增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
]]></content>
    <summary type="html">
    <![CDATA[本文从简单工厂模式的缺点说起，引入工厂方法模式，介绍的工厂方法模式的基本知识，实现要点和应用场景，最后举例进行说明工厂方法模式的应用。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CSS float属性]]></title>
    <link href="http://luopq.com/2015/11/08/CSS-float/"/>
    <id>http://luopq.com/2015/11/08/CSS-float/</id>
    <published>2015-11-08T13:10:47.000Z</published>
    <updated>2015-12-09T10:59:29.874Z</updated>
    <content type="html"><![CDATA[<p>CSS中的float属性是一个频繁用到的属性，对于初学者来说，如果没有理解好浮动的意义和表现出来的特性，在使用的使用很容易陷入困惑，云里雾里，搞不清楚状态。本文将从最基本的知识开始说起，谈谈关于浮动的应用，出现的问题和解决方案。</p>
<h3 id="基础知识">基础知识</h3><p>float，顾名思义就是浮动，设置了float属性的元素会根据属性值向左或向右浮动，我们称设置了float属性的元素为浮动元素。<br>浮动元素会从普通文档流中脱离，但浮动元素影响的不仅是自己，它会影响周围的元素对齐进行环绕。举例说明如下：<br>Html代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;span <span class="type">class</span>=<span class="string">"float-ele"</span>&gt;</span><br><span class="line">            浮动元素</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流普通文档流</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ff90</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.float-ele</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo1.jpg" alt="float基本效果" title="float基本效果"></p>
<p>由效果图可以看出，span元素周围的文字会围绕着span元素，而设置了float属性的span元素变成了一个块级元素的感觉，可以设置width和height属性。这是设置了float属性后的效果，关于float的详细细节，我们接下来详细讲解。</p>
<h3 id="float的详细细节">float的详细细节</h3><p>在说明float带来的详细细节之前，我们首先要了解一个概念。<br>包含块：浮动元素的包含块就是离浮动元素最近的块级祖先元素，前面叙述的例子中，div.box就是span元素的包含块。</p>
<p>了解完包含块的概念之后，首先要说明的浮动元素的第一个特性：不管一个元素是行内元素还是块级元素，如果被设置了浮动，那浮动元素会生成一个块级框，可以设置它的width和height，因此float常常用于制作横向配列的菜单，可以设置大小并且横向排列。</p>
<p>浮动元素的展示在不同情况下会有不同的规则，下面我们来一一说明这些规则。<br>1.浮动元素在浮动的时候，其margin不会超过包含块的padding<br>这一点很简单，浮动元素的浮动位置不能超过包含块的内边界<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;span <span class="type">class</span>=<span class="string">"rule1"</span>&gt;</span><br><span class="line">            浮动元素</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ff90</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400px</span></span></span>; &#125;</span></span><br><span class="line">        <span class="class">.rule1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo2.jpg" alt="float规则一" title="float规则一"><br>这个例子中，box的padding是10px，浮动元素的margin是10px，合起来为20px，即浮动元素不会超过包含块的padding。<br>PS：如果想要元素超出，可以设置margin属性</p>
<p>2.如果有多个浮动元素，后面的浮动元素的margin不会超过前面浮动元素的margin<br>简单说就是如果有多个浮动元素，浮动元素会按顺序排下来而不会发生重叠的现象。<br>修改前面例子中的HTML代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素1</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素2</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素3</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo3.jpg" alt="float规则二" title="float规则二"></p>
<p>如图所示，浮动元素会一个一个排序下来而不会发生重叠现象。</p>
<p>3.如果两个元素一个向左浮动，一个向右浮动，左浮动元素的marginRight不会和右浮动元素的marginLeft相邻。<br>什么意思呢，我们要分两种情况来看。<br>（1）包含块的宽度大于两个浮动元素的宽度总和，举例如下：<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素1</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"rule2"</span>&gt;</span></span><br><span class="line">            浮动元素2</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ff90</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.rule1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line"><span class="class">.rule2</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo4.jpg" alt="float规则三情况1" title="float规则三情况1"></p>
<p>这种情况很简单：包含块元素的宽度足够大，两个元素一个向左浮动，一个向右浮动，井水不犯河水。</p>
<p>（2）包含块的宽度小于两个浮动元素的宽度总和<br>修改浮动元素的宽度为300px，CSS代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.rule1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line"><span class="class">.rule2</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo5.jpg" alt="float规则三情况2" title="float规则三情况2"></p>
<p>如果所示，如果包含块宽度不够高，后面的浮动元素将会向下浮动，其顶端是前面浮动元素的底端。</p>
<p>4.浮动元素顶端不会超过包含块的内边界底端，如果有多个浮动元素，下一个浮动元素的顶端不会超过上一个浮动元素的底端<br>这条规则简单说就是如果有多个浮动元素，后面的元素高度不会超过前面的元素，并且不会超过包含块。举例如下：<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1浮动元素1</span><br><span class="line">        <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"rule1"</span>&gt;</span></span><br><span class="line">            浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2浮动元素2</span><br><span class="line">        <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ff90</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.rule1</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line"><span class="tag">p</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo6.jpg" alt="float规则四" title="float规则四"><br>如图所示，两个浮动元素，后面的浮动元素不会超过前面的浮动元素</p>
<p>5.如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会不会高于非浮动元素<br>这条规则也是显而易见的，在第4条规则中的例子，浮动元素有一个非浮动元素p，而浮动元素没有超过它。</p>
<p>6.浮动元素会尽可能地向顶端对齐、向左或向右对齐<br>在满足其他规则下，浮动元素会尽量向顶端对齐、向左或向右对齐，在第4条规则中的例子，浮动元素会尽可能靠近不浮动的p元素，左侧对齐<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo7.jpg" alt="float规则六" title="float规则六"></p>
<h3 id="float特殊情况">float特殊情况</h3><p>前面讨论了float需要遵守的一些规则，这些规则都是在比较常见的场景下展示的结果。下面我们来讨论一些不常见的情况。</p>
<h4 id="浮动元素的延伸性">浮动元素的延伸性</h4><p>在说浮动元素的延伸性之前，我们首先来考虑一个比较特殊的例子。<br>我们将span元素放在p元素内，并将其高度设置成高于p元素并且左浮动，这个例子的关键在浮动元素高度高于父元素。<br>HTML代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，</span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"high-float"</span>&gt;</span></span><br><span class="line">            浮动元素比父级元素高</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后在浮动元素之后<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#00ff21</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.high-float</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> orangered</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo8.jpg" alt="浮动元素高度大于父级元素" title="浮动元素高度大于父级元素"></p>
<p>在这个例子中，浮动元素高度高于父元素，可以看到浮动元素超出了父元素的底端。<br>这种情况要怎么解决呢，只要将父元素也设置成浮动即可，我们将第一个p元素设置成左浮动，效果如下<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo9.jpg" alt="浮动元素延伸性" title="浮动元素延伸性"></p>
<p>将父元素p设置成float:left后，浮动元素就会被包含到父元素里面，我们将这个特性成为浮动元素的延伸性。<br>浮动元素的延伸性是什么呢，我们可以将其理解为元素被设置成浮动后，该元素会进行延伸进而包含其所有浮动的子元素</p>
<h4 id="浮动元素超出父级元素的padding">浮动元素超出父级元素的padding</h4><p>在前面提到的第一条规则：浮动元素的外边界不会超过父级元素的内边界。大部分情况下，我们见到的场景都是符合的。但是有一些特殊情况。<br>（1）负margin<br>我们将浮动元素的margin-left设置成负数。<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">    在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，</span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"minus-margin"</span>&gt;</span></span><br><span class="line">        负margin-left</span><br><span class="line">    <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#00ff21</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.minus-margin</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> orangered</span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> -<span class="number">20px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo10.jpg" alt="负maring的浮动元素" title="负maring的浮动元素"></p>
<p>将margin-left设置成负数之后，浮动的子元素明显超出了父元素的内边界，这难道不是违反了第一条规则吗？<br>但仔细想想，这其实是合理的，因为默认情况下marign-left就是0，所以不会超出父元素的内边界，但是将其设置成负数之后，就相当于浮动元素覆盖了自己的内边界一样。<br>我们在从数学的角度来看看这个问题，这个例子中：<br>父元素的margin-left:50px，padding和border默认为0，即内边界所在距离浏览器左侧的位置为50px。<br>浮动的子元素默认情况下距离浏览器左侧的像素应该为50px，但是将其设置成margin-left:20px后，浏览器会进行计算：<br>50px+（-20px）margin+0border+0padding=30px。距离浏览器左侧更近，所以超出了父元素。</p>
<p>（2）浮动元素宽度大于父级元素宽度<br>如果我们将浮动元素的宽度设置大于父级元素，效果会如何呢？<br>元素左浮动，width大于父级元素<br>HTML代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">    在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，</span><br><span class="line">    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"big-width"</span>&gt;</span></span><br><span class="line">        width大于父级元素</span><br><span class="line">    <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#00ff21</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.big-width</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> orangered</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo11.jpg" alt="大width的浮动元素" title="大width的浮动元素"></p>
<p>将浮动元素左浮动，并且宽度超出父级元素时，由于浮动元素宽度较大，它会超过父级元素的右内边界<br>如果将其设置成右浮动，情况又会怎么样呢？<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo12.jpg" alt="大width的浮动元素" title="大width的浮动元素"><br>可以看到，设置成右浮动后，会超出父级元素的左内边界。</p>
<h4 id="重叠问题">重叠问题</h4><p>重叠问题是指两个元素再同一个位置，会出现上下重叠的问题。浮动元素如果和普通文档流发生重叠会怎么样呢？<br>首先浮动元素要怎么样才会发生重叠呢，设置其margin-top为负数即可。我们看看例子：<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span>&gt;</span></span><br><span class="line">            在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前。</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"overlay"</span>&gt;</span></span><br><span class="line">            浮动元素重叠</span><br><span class="line">        <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">20px</span></span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">50px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> <span class="hexcolor">#00ff21</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">250px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.overlay</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">background-color</span>:<span class="value"> orangered</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">300px</span></span></span>; <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> -<span class="number">30px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo13.jpg" alt="浮动元素的重叠问题" title="浮动元素的重叠问题"><br>如果浮动元素不设置负margin时，是这样的<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo14.jpg" alt="浮动元素的重叠问题" title="浮动元素的重叠问题"></p>
<p>在这个例子中，可以看到p中正常流元素span的内容会显示在浮动元素上面。<br>我们给设置span设置背景图片试试，效果如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo15.jpg" alt="浮动元素的重叠问题：有背景图" title="浮动元素的重叠问题：有背景图"></p>
<p>元素设置背景后，重叠的部分还是会显示背景</p>
<p>如果是span标签换成div标签会怎么样呢？<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"background-image:url(../images/banner1.jpg)"</span>&gt;</span></span><br><span class="line">         在浮动元素之前在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前，在浮动元素之前。</span><br><span class="line">     <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"overlay"</span>&gt;</span></span><br><span class="line">         浮动元素重叠</span><br><span class="line">     <span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo16.jpg" alt="浮动元素的重叠问题：块级元素有背景图" title="浮动元素的重叠问题：块级元素有背景图"><br>这种情况下，重叠的部分不会显示背景图片。</p>
<p>总结一下这两种情况的区别：<br>1、行内元素与浮动元素发生重叠，其边框，背景和内容都会显示在浮动元素之上<br>2、块级元素与浮动元素发生重叠时，边框和背景会显示在浮动元素之下，内容会显示在浮动元素之上</p>
<h3 id="clear属性">clear属性</h3><p>有的时候，我们不希望一些元素会被旁边的浮动元素影响到，这个时候就需要用到clear属性了。<br>clear属性：确保当前元素的左右两侧不会有浮动元素。<br>我们举个例子进行说明：<br>假设有3个浮动的div如下所示：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo17.jpg" alt="3个浮动元素" title="浮动元素的重叠问题：3个浮动元素"></p>
<p>它的HTML代码和CSS代码如下<br>HTML代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class">.float</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid red</span></span>; <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">5px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.cl</span> <span class="rules">&#123; <span class="rule"><span class="attribute">clear</span>:<span class="value"> left</span></span>; &#125;</span></span><br><span class="line"><span class="class">.cr</span> <span class="rules">&#123; <span class="rule"><span class="attribute">clear</span>:<span class="value"> right</span></span>; &#125;</span></span><br><span class="line"><span class="class">.cb</span> <span class="rules">&#123; <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>假设有我们有想让第二个浮动元素另起一行进行浮动，那该怎么做呢？<br>根据clear属性的定义：确保当前元素的左右两侧不会有浮动元素。<br>我们对第一个浮动元素添加clear:right保证其右侧不会有浮动元素。修改HTML代码如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float cr"</span>&gt;浮动元素<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>查看效果发现没有什么变化<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo17.jpg" alt="第1个元素清除浮动" title="浮动元素的重叠问题：第1个元素清除浮动"></p>
<p>这种方法是错误的！！</p>
<p>那我们试试给第二个元素添加clear:left保证其左侧不会出现浮动元素。修改HTML代码如下：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">1</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float cl"</span>&gt;浮动元素<span class="number">2</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"float"</span>&gt;浮动元素<span class="number">3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo18.jpg" alt="第2个元素清除浮动" title="浮动元素的重叠问题：第2个元素清除浮动"><br>可以看到这次clear属性有效果了。</p>
<p>同样是设置clear属性，为什么会出现这样的结果呢？<br>使用clear属性的时候要记住：<strong>clear只对元素本身的布局起作用</strong>。<br>在前面的例子中，第一个浮动元素添加了clear属性，它并不会影响到其他元素的布局，只会影响自己，所以第二个浮动元素并不会另起一行。<br>而第二个浮动元素设置了clear后，我们可以看到clear作用于自己，所以元素另起一行。</p>
<h3 id="清除浮动">清除浮动</h3><p>清除浮动是一个经常提到的东西，首先我们要理解使用浮动会带来什么问题，以及为什么要清除浮动。<br>我们知道，一个块级元素如果没有设置height，其height是由子元素撑开的。对子元素使用了浮动之后，子元素会脱离标准文档流，也就是说，父级元素中没有内容可以撑开其高度，这样父级元素的height就会被忽略，这就是所谓的高度塌陷。要解决这样的问题，我们就是要使用清除浮动。<br>清除浮动有很多方法，下面我们一一说明每一种方法。</p>
<p>对于IE浏览器来说，要清除浮动带来的问题，只需要触发器hasLayout就可以，直接设置样式zoom:1就可以触发。关于hasLayout的知识，这里暂不详述，以后我们专门来讲讲这个东西，感兴趣的同学可以先查查相关资料。</p>
<p>对于非IE浏览器，主要有下面几种方法：</p>
<h4 id="增加额外的div">增加额外的div</h4><p>这是最简单直接的方法，哪里有浮动元素，就在其父级元素的内容中增加一个（作为最后一个子元素）<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style=<span class="string">"clear:both"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就会清除浮动元素带来的问题。<br>优点：简单直接，初学者常常使用的方法，也易于理解<br>缺点：增加额外的无意义标签，不利于语义化，每次清除都要添加额外的空标签，造成浪费</p>
<h4 id="父级元素添加overflow:hidden">父级元素添加overflow:hidden</h4><p>这个方法的关键在于触发了BFC，BFC是CSS中的难点之一，我们以后专门来学习这个概念。现在只需要知道它可以清除浮动带来的影响。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.clearfix</span><span class="rules">&#123;<span class="rule"><span class="attribute">overflow</span>:<span class="value">hidden</span></span>;<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span>&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>优点：代码量少，没有额外的标签<br>缺点：如果子元素超出父元素的范围，会造成超出的部分被隐藏</p>
<h4 id="after伪元素">after伪元素</h4><p>after表示子元素的后面，通过它可以设置一个具有clear的元素，然后将其隐藏<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">clearfix</span>:<span class="value">&#123;</span><br><span class="line">    zoom:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">clearfix:after&#123;</span><br><span class="line">    display:block</span></span>; <span class="rule"><span class="attribute">content</span>:<span class="value"><span class="string">''</span></span></span>; <span class="rule"><span class="attribute">clear</span>:<span class="value">both</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">0</span></span></span>; <span class="rule"><span class="attribute">visibility</span>:<span class="value">hidden</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方法的原理和第一个方法一样，就是生成一个元素来清除浮动，只是这个元素是“假的”。<br>优点：没有额外标签，综合起来算是比较好的方法<br>缺点：稍显复杂，但是理解其原理后也挺简单的<br>推荐使用这种方法。</p>
<h3 id="float的应用">float的应用</h3><p>说了这么多float的原理和可能造成的问题，接下来我们就要谈谈float的应用。</p>
<h4 id="文字环绕效果">文字环绕效果</h4><p>float最初的应用就是文字环绕效果，这对图文并茂的文章很有用。我们简单的距离说明一下：<br>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"box"</span>&gt;</span><br><span class="line">        &lt;img src=<span class="string">"1.jpg"</span> <span class="type">class</span>=<span class="string">"float"</span> /&gt;</span><br><span class="line">        我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字我是环绕的文字</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.box</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ff90</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; &#125;</span>  </span><br><span class="line"><span class="class">.float</span> <span class="rules">&#123;<span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;<span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid red</span></span>;<span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>;<span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">5px</span></span></span>;<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">400px</span></span></span>;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo19.jpg" alt="文字环绕效果" title="文字环绕效果"></p>
<p>这样很轻松的实现了文字环绕效果。</p>
<h4 id="横向菜单排列">横向菜单排列</h4><p>在之前提到的display:inline的文章<a href="http://luopq.com/2015/11/01/display-inline-block/">详解CSS display:inline-block的应用</a>中，我们提到了横向排列菜单的实现，最早是利用float属性来实现的，它可以很简单的实现横向菜单的效果。<br>HTML代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"menu clearfix"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>首页<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>政治<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>娱乐<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>体育<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>游戏<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">.clearfix</span>:<span class="value"> &#123; zoom: <span class="number">1</span></span></span>; &#125;</span><br><span class="line">    <span class="rule"><span class="attribute">.clearfix</span>:<span class="value">after &#123; display: block</span></span>; <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">''</span></span></span>; <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>; &#125;</span><br><span class="line"><span class="class">.menu</span> <span class="rules">&#123; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">500px</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.menu</span> <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo20.jpg" alt="横向菜单" title="横向菜单"><br>这种方式可以很轻松的实现横向菜单效果，但需要注意的是要注意清除浮动，推荐使用display:inline-block来实现</p>
<h4 id="布局">布局</h4><p>float最经常使用的场景就是布局。使用float可以很简单的实现布局，而且易于理解。下面我们来实现一个三栏两列的固定布局。<br>HTML代码：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"header"</span>&gt;</span><br><span class="line">    我是头部</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content clearfix"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"side"</span>&gt;左侧&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"main"</span>&gt;</span><br><span class="line">        右侧</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;</span><br><span class="line">    我是底部</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="rule"><span class="attribute">.clearfix</span>:<span class="value"> &#123; zoom: <span class="number">1</span></span></span>; &#125;</span><br><span class="line">    <span class="rule"><span class="attribute">.clearfix</span>:<span class="value">after &#123; display: block</span></span>; <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">''</span></span></span>; <span class="rule"><span class="attribute">clear</span>:<span class="value"> both</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">visibility</span>:<span class="value"> hidden</span></span>; &#125;</span><br><span class="line"><span class="class">.header</span>, <span class="class">.footer</span> <span class="rules">&#123; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">50px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#0094ff</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line"><span class="class">.content</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1000px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#000000</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.side</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> left</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">280px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff006e</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.main</span> <span class="rules">&#123; <span class="rule"><span class="attribute">float</span>:<span class="value"> right</span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">500px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">700px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fbcfcf</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>效果图<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/CSS-float-Demo21.jpg" alt="三栏两列布局" title="三栏两列布局"><br>这就是一个很常见的布局，要注意的就是清除浮动的问题。</p>
<p>float常见的应用大概是这几种，当然它存在着更多的应用等待着大家去挖掘，欢迎交流！！</p>
<h3 id="总结">总结</h3><p>float属性是一个频繁用到的属性，要用好它就要理解它的特性，否则容易云里雾里搞不清楚状况。关于float，最重要的是要理解下面几点：<br>1.float会造成元素脱离文档流<br>2.float影响元素的几个规则<br>3.浮动带来的问题以及如何清除浮动</p>
]]></content>
    <summary type="html">
    <![CDATA[CSS中的float属性是一个频繁用到的属性，对于初学者来说，如果没有理解好浮动的意义和表现出来的特性，在使用的使用很容易陷入困惑，云里雾里，搞不清楚状态。本文将从最基本的知识开始说起，谈谈关于浮动的应用，出现的问题和解决方案。]]>
    
    </summary>
    
      <category term="CSS" scheme="http://luopq.com/tags/CSS/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：简单工厂模式]]></title>
    <link href="http://luopq.com/2015/11/03/design-pattern-factory/"/>
    <id>http://luopq.com/2015/11/03/design-pattern-factory/</id>
    <published>2015-11-02T16:35:48.000Z</published>
    <updated>2015-11-02T16:58:46.886Z</updated>
    <content type="html"><![CDATA[<p>通常我们创建对象最常规的方法就是使用new关键字调用构造函数，这会导致对象之间的依赖性。工厂模式是一种有助于消除类之间依赖性的设计模式，它使用一个方法来决定要实例化哪一个类。本文详细介绍了简单工厂模式的理论，并且举例说明了简单工厂模式的具体应用。</p>
<h4 id="基本介绍">基本介绍</h4><p>简单工厂模式是工厂模式中最基本的一种。通过定义一个工厂类，根据参数实例化具体的某个产品类。</p>
<h4 id="举例说明">举例说明</h4><p>我们举个例子进行说明：假设我们开发一个旅游行业网站，网站上面销售机票，酒店等产品。一个用户准备购买一张机票。我们可以定义相关类如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productEnums = &#123;</span><br><span class="line">    flight: <span class="string">"flight"</span>,</span><br><span class="line">    hotel: <span class="string">"hotel"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Flight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is Flight"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hotel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"This is Hotel"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.shopCart = [];</span><br><span class="line">&#125;</span><br><span class="line">User.prototype = &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>: User,</span><br><span class="line">    order: function (productType) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> product = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (productType) &#123;</span><br><span class="line">            <span class="keyword">case</span> productEnums.flight:</span><br><span class="line">                product = <span class="keyword">new</span> Flight();</span><br><span class="line">            <span class="keyword">case</span> productEnums.hotel:</span><br><span class="line">                product = <span class="keyword">new</span> Hotel();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.shopCart.push(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User();</span><br><span class="line">user.order(productEnums.flight);</span><br></pre></td></tr></table></figure></p>
<p>这段代码定义了三个类：用户类User，机票类Flight，酒店类Hotel，其中User包含预订方法。用户预订的时候直接传入产品类型即可。这段代码乍一看没什么问题，但是需求和业务是随时变化的，如果公司业务扩展，增加了签证业务，我们就要去修改User类来保证它支持签证。我们当然可以这么做，但直接去修改User类有什么不好呢，有没有更好的方法呢？<br>首先要说的是User类，这个类是表示用户类，而用户类本质上跟具体的某一类业务是无关的，也就是说，业务有可能随时增加，但是用户关于业务方面的代码也就是创建产品订单。新增的签证业务本质上和已经存在的机票和酒店没有什么区别，如果每增加一种业务就要去修改User类，这对代码的稳定性和可维护性大大的不好，更好的解决方法是有一个专门的创建订单的类在管理不同的业务，这个类就是简单工厂。<br>我们修改代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> productFactory = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> productFactories = &#123;</span><br><span class="line">        <span class="string">"flight"</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Flight();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"hotel"</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Hotel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createProduct: <span class="function"><span class="keyword">function</span> <span class="params">(productType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> productFactories[productType]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">User.prototype = &#123;</span><br><span class="line">    constructor: User,</span><br><span class="line">    order: <span class="function"><span class="keyword">function</span> <span class="params">(productType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shopCart.push(productFactory.createProduct(productType));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码主要修改的地方有两点：<br>（1）增加了一个产品工厂，根据不同的产品类型返回不同的对象<br>（2）修改User类的order方法为调用工厂类中的创建产品方法。<br>这样做的好处是：<br>（1）使User的order方法更加专注，只做预订产品这一功能，而提取创建产品订单到专门的工厂类中，代码更简洁清晰<br>（2）一个专门管理product的factory，添加新产品很容易，不用再去修改User类</p>
<h4 id="总结说明">总结说明</h4><p>简单工厂模式的主要特点是将对象的创建和使用进行了分离，主要有3个部分组成：<br>1.对象使用类，该类是被工厂创造出来的使用者，与对象的种类和创建过程无关<br>2.工厂类，工厂类根据传入的参数创建不同的对象并返回给对象使用类，包含了不同对象的创建过程，如果有不同的对象，则要修改该类<br>3.对象类，不同业务产生的不同类，就是工厂生产的产品</p>
<h5 id="简单工厂模式优点">简单工厂模式优点</h5><p>1.工厂类集中了所有对象的创建，便于对象创建的统一管理<br>2.对象的使用者仅仅是使用产品，实现了单一职责<br>3.便于扩展，如果新增了一种业务，只需要增加相关的业务对象类和工厂类中的生产业务对象的方法，不需要修改其他的地方。</p>
<h5 id="适用场景">适用场景</h5><p>1.需要根据不同参数产生不同实例，这些实例有一些共性的场景<br>2.使用者只需要使用产品，不需要知道产品的创建细节</p>
<p>注意：除非是适用场景，否则不可滥用工厂模式，会造成代码的复杂度。</p>
]]></content>
    <summary type="html">
    <![CDATA[通常我们创建对象最常规的方法就是使用new关键字调用构造函数，这会导致对象之间的依赖性。工厂模式是一种有助于消除类之间依赖性的设计模式，它使用一个方法来决定要实例化哪一个类。本文详细介绍了简单工厂模式的理论，并且举例说明了简单工厂模式的具体应用。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CSS display:inline-block的应用]]></title>
    <link href="http://luopq.com/2015/11/01/display-inline-block/"/>
    <id>http://luopq.com/2015/11/01/display-inline-block/</id>
    <published>2015-11-01T05:02:11.000Z</published>
    <updated>2015-11-02T16:56:44.337Z</updated>
    <content type="html"><![CDATA[<p>本文详细描述了display:inline-block的基础知识，产生的问题和解决方法以及其常见的应用场景，加深了对inline-block应用的进一步理解。</p>
<h3 id="基础知识">基础知识</h3><p>display:inline-block是什么呢？相信大家对这个属性并不陌生，根据名字inline-block我们就可以大概猜出它是结合了inline和block两者的特性于一身，简单的说：设置了inline-block属性的元素既拥有了block元素可以设置width和height的特性，又保持了inline元素不换行的特性。</p>
<p>举例说明：以前我们做横向菜单列表的时候，我们可以通过li和float:left两者来实现，现在可以通过li和display:inline-block。</p>
<blockquote>
<p>HTML代码</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            首页</span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            关于</span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            热点</span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            联系我们</span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSS代码：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ul</span>, <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; &#125;</span></span><br><span class="line">        <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#000</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果图：</p>
</blockquote>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo1.jpg" alt="inline-block基本效果"></p>
<p>可以看到li元素可以横向排列，并且可以设置width属性，大家可以复制代码自己查看效果或查看<a href="http://runjs.cn/code/2qc4sp6i" target="_blank" rel="external">Demo</a></p>
<h3 id="inline-block的问题">inline-block的问题</h3><p>观察上面的例子，细心的同学肯定会发现，每个li之间有一个小空隙，而我们的代码中并没有设置margin等相关属性，这是为什么呢？</p>
<h4 id="默认的inline元素">默认的inline元素</h4><p>首先，我们观察一下默认的inline元素的表现：</p>
<blockquote>
<p>HTML代码</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">a</span>&gt;</span>首页<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span>&gt;</span>热点<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSS代码</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#000</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果图</p>
</blockquote>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo2.jpg" alt="inline默认情况"></p>
<p>默认情况下，inline元素之间就有空隙出现，所以结合了inline和block属性的inline-block属性自然也有这个特点。<br>那这些空隙是什么呢，它们是空白符！</p>
<h4 id="消除空白符">消除空白符</h4><p>在浏览器中，空白符是不会被浏览器忽略的，多个连续的空白符浏览器会自动将其合并成一个。我们编写代码时写的空格，换行都会产生空白符。所以自然而然的两个元素之间会有空白符，如果将上述例子中的a标签写成一行，空白符消失，菜单之间也就紧凑起来了。</p>
<p>空白符虽然是浏览器正常的表现行为，但是通常情况下，设计师同学的设计稿不会出现这些空隙，我们在还原设计稿的时候，怎么去除掉这些空隙呢。<br>要去除空白符产生的间隙，首先要理解空白符归根结底是个字符，通过设置font-size属性可以控制产生的间隙的大小。<br>首先我们将font-size设置成50px试试，修改CSS代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ul</span>, <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">50px</span>&#125;</span><br><span class="line">        li &#123; display: inline-block</span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#000</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">12px</span> &#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>我们修改ul的font-size为50px，而li的font-size为12px保持原来的字体大小，效果如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo3.jpg" alt="font-size:50px的空隙"><br>可以看到菜单之间的空隙变大了。<br>接着我们设置font-site属性为0px，代码如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ul</span>, <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">0px</span>&#125;</span><br><span class="line">        li &#123; display: inline-block</span></span>; <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#000</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">12px</span> &#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo4.jpg" alt="font-size:0的空隙"><br>可以看到菜单之间的空隙没有了，大家可以自行查看<a href="http://runjs.cn/code/2qc4sp6i" target="_blank" rel="external">Demo</a></p>
<h4 id="兼容性问题">兼容性问题</h4><p>在IE8+，FF和Chrome的浏览器，inline-block可以完美的兼容，考虑到IE6和IE7等低版本浏览器的占用率，虽然有办法可以兼容，但本文不再赘述，大家有兴趣的可以查找相关资料。</p>
<h3 id="inline-block的应用">inline-block的应用</h3><p>inline-block的应用什么场景有哪些呢？我们大家考虑一个技术的应用场景时，首先一定要思考的是技术的特性和需求是否符合。inline-block的特点是结合inline和block两种属性的特性，可以设置width和height，并且元素保持行内排列的特性，基于这一点，所有行内排列并且可以设置大小的场景都是我们可以考虑使用inline-block的应用场景。下面举例说明：</p>
<h4 id="网页头部菜单">网页头部菜单</h4><p>网页头部的菜单就是典型的横向排列并且需要设置大小的应用，在inline-block之前，实现菜单基本都是用float属性来实现，float属性会造成高度塌陷，需要清除浮动等问题，使用inline-block实现就不需要在意这样的问题。代码如下：</p>
<blockquote>
<p>HTML代码：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>服装城<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>美妆馆<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>超市<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>全球购<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>闪购<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>团购<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>拍卖<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>金融<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>智能<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSS代码</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span>, <span class="tag">ul</span>, <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">list-style-type</span>:<span class="value"> none</span></span>; &#125;</span></span><br><span class="line"><span class="tag">a</span> <span class="rules">&#123; <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> none</span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#333</span></span></span>; &#125;</span> </span><br><span class="line"><span class="class">.header</span> <span class="tag">ul</span> <span class="rules">&#123; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br><span class="line">       <span class="class">.header</span> <span class="tag">li</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">80px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果图</p>
</blockquote>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo5.jpg" alt="京东首页导航菜单"></p>
<p>这是模仿京东首页头部导航菜单的实现，使用inline-block可以很简单的实现横向菜单列表</p>
<h4 id="内联块元素">内联块元素</h4><p>除了菜单之外，一切需要行内排列并且可设置大小的需求就可以用inline-block来实现。<br>例如使用a标签做按钮时，需要设置按钮的大小，我们就可以使用inline-block来实现。</p>
<blockquote>
<p>HTML代码：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">    点击右边的按钮直接购买</span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:;"</span> <span class="attribute">class</span>=<span class="value">"button"</span>&gt;</span></span><br><span class="line">        购买</span><br><span class="line">    <span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSS代码：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.button</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">45px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#b61d1d</span></span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">45px</span></span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果图</p>
</blockquote>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo6.jpg" alt="a标签菜单"></p>
<h4 id="布局">布局</h4><p>inline-block也可以用于常见的布局，使用它就不需要去注意float属性布局带来的问题。<br>举例说明，创建一个常见的3列布局。</p>
<blockquote>
<p>HTML代码：</p>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"wrap"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"header"</span>&gt;</span><br><span class="line">        网页头部</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"content"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"left"</span>&gt;</span><br><span class="line">            左侧</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"center"</span>&gt;</span><br><span class="line">            中间</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"right"</span>&gt;</span><br><span class="line">            右侧</span><br><span class="line">        &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;</span><br><span class="line">        网页底部</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>CSS代码</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span>, <span class="tag">div</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>; <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.header</span>, <span class="class">.footer</span> <span class="rules">&#123; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ccc</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">120px</span></span></span>; <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>; <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">120px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.content</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ff6a00</span></span></span>; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">1000px</span></span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">0</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.content</span> <span class="class">.left</span>, <span class="class">.content</span> <span class="class">.center</span>, <span class="class">.content</span> <span class="class">.right</span> <span class="rules">&#123; <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>; <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>; <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">400px</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.content</span> <span class="class">.left</span>, <span class="class">.content</span> <span class="class">.right</span> <span class="rules">&#123; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>; &#125;</span></span><br><span class="line">    <span class="class">.content</span> <span class="class">.center</span> <span class="rules">&#123; <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">600px</span></span></span>; <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#00ffff</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果图：</p>
</blockquote>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/displayInlineBlock-demo7.jpg" alt="inline-block的三列布局"><br>这个例子使用了inline-block做出了常见的网页布局。</p>
<p>关于inline-block的应用，只要是从左到右，从上到下，并且需要设置大小的列表都可以用它来实现，而这种需求是非常常见的，相比于float，我更推荐inline-block。inline-block的应用应该还有很多，大家可以多多挖掘出来。</p>
<h3 id="总结">总结</h3><p>相比于使用float所带来的问题，使用inline-block所需要注意的点主要是空白符带来的问题，这一点也可以很方便的解决。<br>使用inline-block可以很方便的进行列表布局，更加符合我们的思维习惯，相信使用它的同学们也会越来越多，欢迎大家讨论。</p>
]]></content>
    <summary type="html">
    <![CDATA[本文详细描述了display:inline-block的基础知识，产生的问题和解决方法以及其常见的应用场景，加深了对inline-block应用的进一步理解。]]>
    
    </summary>
    
      <category term="CSS" scheme="http://luopq.com/tags/CSS/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript设计模式理论与实战：单例模式]]></title>
    <link href="http://luopq.com/2015/10/27/design-pattern-singleton/"/>
    <id>http://luopq.com/2015/10/27/design-pattern-singleton/</id>
    <published>2015-10-27T14:19:11.000Z</published>
    <updated>2015-11-02T16:59:30.099Z</updated>
    <content type="html"><![CDATA[<p>在Javascript中，单例模式是一种最基本又经常用到的设计模式，可能在不经意间就用到了单例模式。<br>本文将从最基础的理论开始，讲述单例模式的基本概念和实现，最后用一个例子来讲述单例模式的应用。</p>
<h3 id="理论基础">理论基础</h3><h4 id="概念">概念</h4><p>单例模式，顾名思义就是只有一个实例存在。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<h4 id="基本结构">基本结构</h4><p>最简单的单例模式起始就是一个对象字面量，它将有关联的属性和方法组织到一起。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    prop:<span class="string">"value"</span>,</span><br><span class="line">    <span class="keyword">method</span>:function()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种形式的单例模式，所有成员都是公开的，都可以通过singleton来访问。这样的缺点是单例中有一些辅助的方法并不希望暴露给使用者，如果使用者用了这些方法，然后在后面维护的时候，一些辅助方法被删除，这样会造成程序错误。<br>如何避免这样从的错误呢？</p>
<h4 id="包含私有成员的单例模式">包含私有成员的单例模式</h4><p>要怎么在类中创建私有成员呢，这通过需要闭包来进行实现，关于闭包的知识，本文不再赘述，大家可以自行Google。<br>基本形式如下：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = (function () &#123;</span><br><span class="line">            <span class="keyword">var</span> privateVar = <span class="string">"private"</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                prop: <span class="string">"value"</span>,</span><br><span class="line">                <span class="keyword">method</span>: function () &#123;</span><br><span class="line">                    console.log(privateVar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();</span><br></pre></td></tr></table></figure></p>
<p>首先是一个自执行的匿名函数，在匿名函数中，声明了一个变量privateVar，返回一个对象赋值给单例对象singleton。在匿名函数外部无法访问到privateVar变量，它就是单例对象的私有变量，只能在函数内部或通过暴露出来的方法去访问这个私有变量。这种形式又被成为模块模式。</p>
<h4 id="惰性实例化">惰性实例化</h4><p>不管是直接字面量或者私有成员的单例模式，两者都是在脚本加载时就被创建出来的单例，但是有时候，页面可能永远也用不到这个单例对象，这样会造成资源浪费。对于这种情况，最佳的处理方式就是惰性加载，就是说在需要的时候才去真正实例化这个单例对象，如何实现呢？<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var singleton =<span class="function"> (</span>function<span class="function"> (</span><span class="function">)</span> &#123;</span><br><span class="line">            function<span class="function"> init(</span><span class="function">)</span> &#123;</span><br><span class="line">                var<span class="keyword"> private</span>Var = <span class="string">"private"</span>;</span><br><span class="line">               <span class="instruction"> return </span>&#123;</span><br><span class="line">                    prop: <span class="string">"value"</span>,</span><br><span class="line">                    method: function<span class="function"> (</span><span class="function">)</span> &#123;</span><br><span class="line">                       <span class="function"> console.log(</span>privateVar<span class="function">)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            var<span class="instruction"> instance </span>= null;</span><br><span class="line">           <span class="instruction"> return </span>&#123;</span><br><span class="line">                getInstance: function<span class="function"> (</span><span class="function">)</span> &#123;</span><br><span class="line">                   <span class="instruction"> if </span>(!instance<span class="function">)</span> &#123;</span><br><span class="line">                       <span class="instruction"> instance </span>=<span class="function"> init(</span><span class="function">)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                   <span class="instruction"> return </span>instance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="function"> &#125;)(</span><span class="function">)</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先将创建单例对象的代码封装到init函数中，然后声明一个私有变量instance表示单例对象的实例，公开一个方法getInstance来获取单例对象。<br>调用的时候就通过singleton.getInstance()来进行调用，单例对象是在调用getInstance的时候才真正被创建。</p>
<h4 id="适用场合">适用场合</h4><p>单例模式是JS中最常使用的设计模式，从增强模块性和代码组织性等方面来说，应该尽可能的使用单例模式。它可以把相关代码组织到一起便于维护，对于大型项目，每个模块惰性加载可以提高性能，隐藏实现细节，暴露出常用的api。常见的类库比如underscore，jQuery我们都可以将其理解为单例模式的应用。</p>
<h3 id="结合实战">结合实战</h3><p>前面已经讲过，单例模式是最常用的设计模式之一，我们来举个例子进行说明，<br>下面的代码主要实现一个简单的日期帮助类，通过单例模式实现：</p>
<h4 id="基本的单例模式结构">基本的单例模式结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dateTimeHelper = &#123;</span><br><span class="line">            now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">            format: <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> date.getFullYear() + <span class="string">"-"</span> + (date.getMonth() + <span class="number">1</span>) + <span class="string">"-"</span> + date.getDate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dateTimeHelper.now());</span><br></pre></td></tr></table></figure>
<p>这段代码通过对象字面量实现单例模式，使用的时候直接调用方法即可。</p>
<h4 id="惰性加载实现单例模式">惰性加载实现单例模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> dateTimeHelper = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">                    &#125;,</span><br><span class="line">                    format: <span class="function"><span class="keyword">function</span> (<span class="params">date</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> date.getFullYear() + <span class="string">"-"</span> + (date.getMonth() + <span class="number">1</span>) + <span class="string">"-"</span> + date.getDate();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                        instance = init();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> instance;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)();  </span><br><span class="line"><span class="built_in">console</span>.log(dateTimeHelper.getInstance().now())</span><br></pre></td></tr></table></figure>
<p>这就是惰性加载的单例模式。</p>
<h3 id="总结">总结</h3><p>单例模式的好处在于对代码的组织作用，将相关的属性和方法封装在一个不会被多次实例化的对象中，让代码的维护和调试更加轻松。隐藏了实现细节，可以防止被错误修改，还防止了全局命名空间的污染。另外可以通过惰性加载提高性能，减少不必要的内存消耗。</p>
]]></content>
    <summary type="html">
    <![CDATA[在Javascript中，单例模式是一种最基本又经常用到的设计模式，可能在不经意间就用到了单例模式。本文将从最基础的理论开始，讲述单例模式的基本概念和实现，最后用一个例子来讲述单例模式的应用。]]>
    
    </summary>
    
      <category term="Javascript" scheme="http://luopq.com/tags/Javascript/"/>
    
      <category term="设计模式" scheme="http://luopq.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CSS盒模型]]></title>
    <link href="http://luopq.com/2015/10/26/CSS-Box-Model/"/>
    <id>http://luopq.com/2015/10/26/CSS-Box-Model/</id>
    <published>2015-10-26T08:41:05.000Z</published>
    <updated>2015-12-06T06:47:12.319Z</updated>
    <content type="html"><![CDATA[<p>本文主要是学习CSS盒模型的笔记，总结了一些基本概念，知识点和细节。</p>
<h3 id="一些基本概念">一些基本概念</h3><p>HTML的大多数元素都是块级(block)元素或行内(inline)元素</p>
<h4 id="块级元素">块级元素</h4><p>默认情况下，块级元素会另起一行，并尽可能的充满整个容器。<br>块级元素可以包含行内元素和其他块级元素，相比于行内元素可以创建更复杂和大型的结构</p>
<h5 id="块级元素列表：">块级元素列表：</h5><p>html5新增的元素：<br>figcation：图文信息组标题 ，article：文章，figure：图文信息组<br>output：表单输出，aside：侧栏内容，footer：区段尾或页尾，audio：音频播放<br>video：视频播放，section：页面区段，canvas：画布、绘制图形，header：区段头或页头<br>hgroup：标题组，</p>
<p>address：联系方式信息，ol：有序列表，p：行，form：表单，pre：预格式化文本，blockqute：块引用<br>h1-h6：标题，table：表格，dd：列表中条目描述，dl：定义列表，div，hr：水平分割线</p>
<h4 id="行内元素">行内元素</h4><p>行内元素不会另起一行只占据它对应的标签的边框所包含内容的空间，<br>只能包含数据和其他行内元素</p>
<h5 id="行内元素列表">行内元素列表</h5><p>b，big，i，small，tt，<br>abbr，acronym，cite，code，dfn，em，kbd，strong，samp，var，<br>a，bdo，br，img，map，object，q，script，span，sub，sup，<br>button，input，label，select，textarea</p>
<h4 id="块级元素和行内元素的区别">块级元素和行内元素的区别</h4><p>块级元素：<br>1.会另起一行，<br>2.可以设置width，height，margin，padding，border属性<br>3.默认宽度是容器的100%</p>
<p>行内元素：<br>1.和其他元素在同一行内<br>2.高度和宽度就是内容的高度和宽度<br>3.可以设置margin-left和margin-right属性，无法设置margin-top和margin-bottom属性<br>4.border和padding可以设置，但是border-top和padding-top到页面顶部后就不再增加</p>
<h4 id="正常流">正常流</h4><p>正常流指：从左到右，从上到下显示。要让一个元素不在正常流中，唯一的办法是让元素浮动或定位</p>
<h4 id="非替换元素">非替换元素</h4><p>如果元素的内容包含在文档中，则称之为非替换元素。比如一个段落的文本都在该元素本身之内，这个段落就是一个非替换元素。</p>
<h4 id="替换元素">替换元素</h4><p>作为其他内容占位符的一个元素称为替换元素，根据标签和属性的值来显示内容的元素。比如img元素，它只是指向一个图像文件，这个文件插入到文档流中。大多数表单元素（input，根据type属性来显示内容）也是替换元素。</p>
<h4 id="根元素">根元素</h4><p>位于文档树的顶端，在html文档中就是html元素</p>
<h3 id="盒模型">盒模型</h3><p>html文档中的每个元素都被描绘成矩形盒子，这些矩形盒子通过一个模型来描述其占用空间，这个模型称为盒模型。盒模型通过四个边界来描述：margin（外边距），border（边框），padding（内边距），content（内容区域），如图所示：<br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model.jpg" alt="CSS盒模型" title="CSS盒模型"></p>
<h4 id="几点提示">几点提示</h4><p>1.padding，border，margin都是可选的，默认值为0，但是浏览器会自行设置元素的margin和padding，通过在css样式表中设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">0</span></span><br><span class="line">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>来覆盖浏览器样式。注意：这里的*表示所有元素，但是这样性能不好，建议一次列出常用的元素来设置</p>
<p>2.如果给元素设置背景，并且边框的颜色为透明，背景将应用于内容，内边距和边框组成的区域。</p>
<p>3.浏览器兼容性<br>一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。<br>根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。<br>不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p>
<h4 id="水平格式化">水平格式化</h4><h5 id="非替换元素的水平格式化">非替换元素的水平格式化</h5><p>水平格式化的7大属性是：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right。这7个属性值加起来往往是父级元素的width值。</p>
<p>其中margin-left，width，margin-right可以设置为auto。<br>主要有下面几种情况：</p>
<h6 id="一个属性设置成auto">一个属性设置成auto</h6><p>如果三个属性中某个属性设置了auto，其余两个为特定的值，那么设置auto的属性为确定所需的元素，从而使得元素框的宽度等于父级元素的width。</p>
<blockquote>
<p>例子</p>
</blockquote>
<p>HTML代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;span <span class="type">class</span>=<span class="string">"block"</span>&gt;块级元素&lt;/span&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>CSS代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.parent</span><span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">600px</span></span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    background: <span class="hexcolor">#eeb3b3</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo1.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo1.2.jpg" alt=""></p>
<p>被设置为auto的margin-auto属性值为340px，即margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=340+0+30+100+30+0+100=600</p>
<h6 id="总和不等于父级元素的width">总和不等于父级元素的width</h6><p>使用auto可以弥补实际值与所需总和的差距，如果三个属性都设置了特定值，但是总和不等于父级元素的width。<br>修改上面例子中的margin-left为100px，即<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo2.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo2.2.jpg" alt=""></p>
<p>在上面的CSS中，margin-left，width，margin-right都设置了特定值，但是七大属性总和不等于父级元素的width。这种情况下：<br>在FF中，margin-right的值为开发者设定的值<br>在Chrome中，margin-right被强制为auto</p>
<h6 id="width设置为auto">width设置为auto</h6><p>如果margin-left和margin-right都设置特定值，width设置为auto，则width将会等于某个特定值以达到父级元素的width。<br>如果将width修改为auto，即：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo3.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo3.2.jpg" alt=""></p>
<p>元素的width将被被设定为340px来使总和达到父级元素的width</p>
<h6 id="margin-left和margin-right设置成auto">margin-left和margin-right设置成auto</h6><p>如果margin-left和amrgin-right都设置为auto，则它们会设置相等的值，因此元素将在父级元素中居中。这是将块级元素居中的一种方法。注意：text-align设置为center只适用于块级元素中的内联内容居中，并不能使块级元素居中。<br>设置margin属性为margin:0 auto<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> auto</span></span>;    </span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo4.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo4.2.jpg" alt=""><br>margin-left和margin-right的值会被设置为相等，使得元素居中</p>
<h6 id="某个外边距和width设置成auto">某个外边距和width设置成auto</h6><p>如果设置某个外边距和width为auto，则设置为auto的外边距会为0，width会设置为所需的值来填充父级元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo5.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo5.2.jpg" alt=""><br>设置margin-left和width为auto，则margin-left将被设置为0，width会被设置为440px来满足父级元素的width</p>
<h6 id="全设置成auto">全设置成auto</h6><p>如果margin和width都设置为auto，则两个外边距会设置为0，width会尽可能宽。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo6.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo6.2.jpg" alt=""></p>
<p>三个值都设置为auto，则两个外边距会设置为0，width会被设置为540px</p>
<h6 id="负外边距">负外边距</h6><p>7个属性只要都是大于等于0的值，总和总是等于父级元素的width，不会超过父级元素的区域<br>但是可以通过制定负外边距来得到比父级元素width更大的区域<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.block</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#ffd800</span> none repeat scroll <span class="number">0</span> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-left</span>:<span class="value"> <span class="number">100px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-right</span>:<span class="value"> -<span class="number">400px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> auto</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo7.1.jpg" alt=""><br><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo7.2.jpg" alt=""></p>
<p>设置margin-right为-400px，则元素会大于父级元素width，因为100+0+30+840+30+0-400=600，元素的width为840px</p>
<h5 id="替换元素的水平格式化">替换元素的水平格式化</h5><p>替换元素的水平格式化规则和非替换元素的规则类似，只有一个width有区别，如果width设置为auto，则元素的宽度是内容的固有宽度。注意：对于img标签，如果width不等于其固有宽度，则height也会等比例增加，除非设置特定值。反过来如果height设置高度，width也会等比例增加</p>
<h4 id="垂直格式化">垂直格式化</h4><p>垂直格式化和水平格式化类似，也有7个相关属性：margin-top，border-top，padding-top，height，padding-bottom，border-bottom，margin-bottom，这7个属性的总和必须等于父级元素的height属性。<br>其中margin-top，margin-bottom和height可以设置成auto<br>一个正常流中的块元素的margin-top和margin-bottom设置为auto后，会被设置为0，即不能将元素垂直居中，实际上元素没有外边距。定位元素如果设置成auto有不同的处理结果。</p>
<p>如果正常流元素的height设置为auto，则其高度将会被设置为其内容元素的高度总和。</p>
<h5 id="垂直外边距合并">垂直外边距合并</h5><p>垂直外边距合并：当两个盒子（可能是兄弟关系也可能是祖先关系）的垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p>
<blockquote>
<p>例子</p>
</blockquote>
<p>html代码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"m20"</span>&gt; 外边距<span class="number">20</span>px &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"m10"</span>&gt; 外边距<span class="number">10</span>px &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>css代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.m20</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">20px</span></span></span>; &#125;</span></span><br><span class="line"><span class="class">.m10</span> <span class="rules">&#123; <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xnjy3.com1.z0.glb.clouddn.com/box-model-demo8.jpg" alt=""><br>如图所示，两个div标签的外边距分别是20px，10px，但是最终两个div之间的距离是20px，而不是20+10=30px</p>
<h4 id="行内元素的盒模型">行内元素的盒模型</h4><p>行内元素也是有盒模型的，但是有几点要注意：<br>1.对于非替换元素，比如a，span标签等<br>（1）可以设置margin-left和margin-right属性，无法设置margin-top和margin-bottom属性<br>（2）行内元素border和padding可以设置，但是border-top和padding-top到页面顶部后就不再增加<br>2.对于替换元素，比如input，img标签<br>margin，padding，border都有效果</p>
]]></content>
    <summary type="html">
    <![CDATA[本文主要是学习CSS盒模型的笔记，总结了一些基本概念，知识点和细节。HTML的大多数元素都是块级(block)元素或行内(inline)元素。<br/>块级元素：默认情况下，块级元素会另起一行，并尽可能的充满整个容器。块级元素可以包含行内元素和其他块级元素，相比于行内元素可以创建更复杂和大型的结构。<br/>行内元素：行内元素不会另起一行只占据它对应的标签的边框所包含内容的空间，只能包含数据和其他行内元素。<br/>盒模型：html文档中的每个元素都被描绘成矩形盒子，这些矩形盒子通过一个模型来描述其占用空间，这个模型称为盒模型。盒模型通过四个边界来描述：margin（外边距），border（边框），padding（内边距），content（内容区域）。]]>
    
    </summary>
    
      <category term="CSS" scheme="http://luopq.com/tags/CSS/"/>
    
      <category term="Web前端" scheme="http://luopq.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[蚁人和头脑特工队]]></title>
    <link href="http://luopq.com/2015/10/17/movie-reviews-for-Ant-Man-and-Inside-Out/"/>
    <id>http://luopq.com/2015/10/17/movie-reviews-for-Ant-Man-and-Inside-Out/</id>
    <published>2015-10-17T10:01:02.000Z</published>
    <updated>2015-10-26T13:16:21.673Z</updated>
    <content type="html"><![CDATA[<p>&emsp;&emsp;国庆放假后连上了9天班，终于找到机会放松了。看了两部电影，想写点东西</p>
<h4 id="蚁人">蚁人</h4><p>&emsp;&emsp;又一部典型的超级英雄片,落魄的主角如何逆袭成为英雄，但不同于其他英雄，他只是想成为自己女儿心中的英雄。整篇看下来幽默搞笑，又萌又酷的英雄，逗比的配角插科打诨的本事无缝穿插中，最后的结局也很温馨。  </p>
<p>&emsp;&emsp;主角变小后的微观视角很棒，我相信很多人都会想象自己变小后的感受。在浴缸，D厅，下水道，电路板，还有最后的在iphone手机和玩具里的打斗，每个场景都很有想象力。微观视角和正常视角的切换十分自然，充满幽默感。</p>
<p>&emsp;&emsp;除了主角本身充满喜剧效果，三个逗比同伙表现得也很棒，各有特点。不同于其他严肃的英雄导师，发明蚁人盔甲的导师也时不时冒出几句逗乐观众的台词。我喜欢这种有亮点但有不抢镜的配角安排。</p>
<p>&emsp;&emsp;影片中的打斗戏很棒，主角忽大忽小的变换和打斗很酷而且自带萌点和趣味。他没有什么特别具有杀伤力的招数，有的只是普通人的拳头，关键在于怎么灵活运用自己变小的能力来击败对手。</p>
<p>&emsp;&emsp;对于这类标准的美国英雄片，我最不喜欢的大概就是和主角对立的反派总是拥有和主角类似的超能力，而且能力更强大。在前面反派介绍自己黄蜂战衣的时候，大概就能猜出反派是个什么样的人物了。</p>
<p>&emsp;&emsp;总的来说，一部让我喜欢的英雄电影，4星推荐。</p>
<h4 id="头脑特工队">头脑特工队</h4><p>&emsp;&emsp;特别有创意特别有想象力的一部动画片，第一次发现我们的情绪，思维还可以通过这样的形式表现出来。虽然是一部动画片，但感觉这是一部更适合大人看的动画片。</p>
<p>&emsp;&emsp;影片中很有想象力的将我们情绪展现为头脑中住的五个代表不同情绪的小家伙来掌控。由乐乐为领导，控制着整个大脑的运行，努力为小女孩创造更多的美好记忆。在乐乐和忧忧因为意外脱离控制总部，进入大脑运行的世界。脑中世界不同的岛屿代表不同的情感联系，记忆垃圾场，造梦工厂，想象出来的伙伴，记忆清理工，很形象的展示了大脑的运行。</p>
<p>&emsp;&emsp;与其他情绪不同的是，悲伤具有感染记忆的能力，她能让曾经美好的记忆带点忧伤的成分，所以快乐总是在阻止悲伤接触任何东西，甚至画了一个圈来限制悲伤的行动自由，但没有忧伤的情绪显然是不完整的。在脑中世界和忧伤一起经历过各种冒险的领导快乐也知道应该让忧伤去做她适合的工作，让重塑的情感岛屿更具坚固性。</p>
<p>&emsp;&emsp;影片中也展示了爸爸和妈妈脑袋里的五个家伙。爸爸脑袋里领导情绪是愤怒，妈妈里的领导情绪是忧伤，而小女孩的领导情绪是快乐。什么样的情绪主导，整个人表现出来的状态就是怎么样的。随着成长和精力，我们的情绪领导也许会从最初的快乐在进行转变，我们肯定悲伤的价值，但我们应该让快乐成为主导。</p>
<p>&emsp;&emsp;我脑海的的情绪小家伙，又是怎么样的组成呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[国庆放假后连上了9天班，终于找到机会放松了。看了两部电影，想写点东西。]]>
    
    </summary>
    
      <category term="电影" scheme="http://luopq.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="娱乐" scheme="http://luopq.com/categories/%E5%A8%B1%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <link href="http://luopq.com/2015/10/15/learn-markdown/"/>
    <id>http://luopq.com/2015/10/15/learn-markdown/</id>
    <published>2015-10-15T12:10:33.000Z</published>
    <updated>2015-10-26T13:16:21.672Z</updated>
    <content type="html"><![CDATA[<h3 id="基本语法">基本语法</h3><h4 id="标题">标题</h4><p>一级标题： # 一级标题<br>二级标题： ## 二级标题<br>三级标题： ### 三级标题<br>四级标题： #### 四级标题<br>五级标题： ##### 五级标题<br>六级标题： ###### 六级标题</p>
<h4 id="列表">列表</h4><p>无序列表 ：在文字前加上“-”或“*”  </p>
<ul>
<li>1  </li>
<li>2  </li>
<li>3</li>
</ul>
<p>有序列表：直接加上1. 2.  </p>
<ol>
<li>第一项  </li>
<li>第二项  </li>
<li>第三项  </li>
</ol>
<h4 id="引用">引用</h4><p>在文本前面加上 &gt; （大于号）</p>
<blockquote>
<p>这是一段引用文字</p>
</blockquote>
<h4 id="图片和链接">图片和链接</h4><p>图片和链接的区别在于 ! 感叹号</p>
<p>图片：<code>![图片替代文字](图片链接)</code><br>插入图片：<br><img src="http://tp4.sinaimg.cn/1836010911/180/5614933698/1" alt="我的头像"></p>
<p>链接：<code>[链接名称](链接地址)</code><br>插入链接：<a href="luopq.com">我的博客</a></p>
<h4 id="粗体和斜体">粗体和斜体</h4><p>用两个”*“包含就是粗体：<code>**粗体**</code><br><strong>这里是粗体</strong>  </p>
<p>用一个”*“包含就是斜体：<code>*斜体*</code><br><em>这里是斜体</em></p>
<h4 id="表格">表格</h4><pre><code>|<span class="string"> 第一列 </span>|<span class="string"> 第二列 </span>|<span class="string"> 第三列 </span>|
|<span class="string">-------</span>|<span class="string">-------</span>|<span class="string">-------</span>|
|<span class="string">   1   </span>|<span class="string">   2   </span>|<span class="string">   3   </span>|
</code></pre><table>
<thead>
<tr>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="代码框">代码框</h4><p>三种方式:  </p>
<ol>
<li>行内代码：使用符号”`“包裹起来，在ESC键下面<br> <code>var a = 0</code>  </li>
<li><p>块代码：使用tab键缩进或空格缩进四个    </p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="string">"test"</span>);
}   
</code></pre></li>
<li><p>前后使用三个”`“将代码包裹起来  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Markdown的基本语法，只要掌握几个概念就能畅快写字啦]]>
    
    </summary>
    
      <category term="markdown" scheme="http://luopq.com/tags/markdown/"/>
    
  </entry>
  
</feed>
